<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Python programming</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Python programming</h1>
</div>
<!-- MarkdownTOC -->
<ul>
<li><a href="#python-basic-skills">Python basic skills</a></li>
<li><a href="#installing-packages">Installing packages</a></li>
<li><a href="#image-datasets">Image datasets</a></li>
<li><a href="#contents">Contents</a>
<ul>
<li><a href="#basic-image-handling-and-processing">Basic image handling and processing</a></li>
<li><a href="#local-image-descriptors">Local image descriptors</a></li>
<li><a href="#image-to-image-mappings">Image to image mappings</a></li>
<li><a href="#camera-models-and-augmented-reality">Camera models and augmented reality</a></li>
<li><a href="#multiple-view-geometry">Multiple view geometry</a></li>
<li><a href="#clustering-images">Clustering images</a></li>
<li><a href="#searching-images">Searching images</a></li>
<li><a href="#classifying-image-content">Classifying image content</a></li>
<li><a href="#image-segmentation">Image segmentation</a></li>
<li><a href="#opencv">OpenCV</a></li>
</ul></li>
</ul>
<!-- /MarkdownTOC -->
<h2 id="python-installl">Python installl</h2>
<ol style="list-style-type: decimal">
<li><p>Python installation If you do not have permission to modify your site-packages directory you can specify an alternative installation prefix using:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">python setup.py develop <span class="op">--</span>prefix<span class="op">=~/</span>.local</code></pre></div></li>
<li><p>Anaconda <a href="http://blog.csdn.net/springzfx/article/details/39699989">python科学计算之Anaconda</a></p></li>
</ol>
<h3 id="reference">Reference</h3>
<p>There is a guide for python programming, <a href="http://www.tutorialspoint.com/python/python_gui_programming.htm">Python GUI Programming (Tkinter)</a> <a href="https://github.com/willard-yuan/pcv-book-code">Programming Computer Vision with Python中译本整理代码</a></p>
<p>This blog is the study record of &quot;Programming Computer Vision with Python&quot;, here are the resource <a href="https://github.com/gujiuxiang/pcv-book-code">code</a> and <a href="http://pan.baidu.com/s/1bvXFYY">data</a>.<br/> If you do not have privileges to install your packages(e.g., server), I recommend you install Anaconda, and I also recommend you to install the following modules.</p>
<h1 id="python-basic-skills">Python basic skills</h1>
<ol style="list-style-type: decimal">
<li>Debug<br/>
<ul>
<li>Viewing all defined variables<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">dir</span>() <span class="co">#will give you the list of in scope variables:</span>
<span class="bu">globals</span>() <span class="co">#will give you a dictionary of global variables</span>
<span class="bu">locals</span>() <span class="co">#will give you a dictionary of local variables</span></code></pre></div>
<ul>
<li>Access HDF5 data from Python<br/></li>
</ul>
<p>https://confluence.slac.stanford.edu/display/PSDM/How+to+access+HDF5+data+from+Python</p>
<ul>
<li>Use pdb<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pdb<span class="op">;</span> pdb.set_trace()</code></pre></div>
<p><span style="color:red"><strong>Reference:</strong></span> <a href="https://github.com/gujiuxiang/gujiuxiang.github.io/blob/master/img/2015-12-20/python_pdb.py">python_pdb</a> / <a href="http://blog.csdn.net/sunboy_2050/article/details/8907268">使用PDB调试Python程序</a> / <a href="http://www.balloonbuilding.com/index.php?chapter=example_code">Program Arcade Games With Python And Pygame</a></p></li>
<li><p>python notebook<br/></p>
<p>Some problems may be encounter: <a href="http://stackoverflow.com/questions/19071512/socket-error-errno-48-address-already-in-use">socket.error: Errno 48 Address already in use</a></p></li>
<li><p>GUI programming<br/></p></li>
<li><p>File access<br/> From local directory or url<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/python</span>

<span class="im">import</span> requests
<span class="im">from</span> StringIO <span class="im">import</span> StringIO
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">import</span> pylab <span class="im">as</span> pl
<span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> read_url_img_show(url):
    <span class="co">&quot;This function read image from url and show&quot;</span>
    response <span class="op">=</span> requests.get(url)
    img <span class="op">=</span> Image.<span class="bu">open</span>(StringIO(response.content))
    imageArray<span class="op">=</span> np.asarray(img)
    pl.imshow(imageArray)
    pl.axis(<span class="st">&#39;off&#39;</span>)
    pl.show()

<span class="co"># main function</span>
<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:
    read_url_img_show(<span class="st">&#39;http://car-pictures.cars.com/images/?IMG=cac10foc051c01401.png&amp;WIDTH=624&amp;AUTOTRIM=1&amp;SPECIAL=&amp;ACT=F&#39;</span>)</code></pre></div></li>
<li><p>Send email</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># send_simple_email_by_account.py @2014-08-18</span>
<span class="co"># author: orangleliu</span>

<span class="im">import</span> smtplib
<span class="im">from</span> email.mime.text <span class="im">import</span> MIMEText

SMTPserver <span class="op">=</span> <span class="st">&#39;smtp.gmail.com&#39;</span>
sender <span class="op">=</span> <span class="st">&#39;xxx@gmail.com&#39;</span>
destination <span class="op">=</span> <span class="st">&#39;xxx@qq.com&#39;</span>
password <span class="op">=</span> <span class="st">&quot;xxx!&quot;</span>

message <span class="op">=</span> <span class="st">&#39;I send a message by Python. hello&#39;</span>
msg <span class="op">=</span> MIMEText(message)

msg[<span class="st">&#39;Subject&#39;</span>] <span class="op">=</span> <span class="st">&#39;Test Email by Python&#39;</span>
msg[<span class="st">&#39;From&#39;</span>] <span class="op">=</span> sender
msg[<span class="st">&#39;To&#39;</span>] <span class="op">=</span> destination

<span class="co"># mailserver = smtplib.SMTP(SMTPserver, 25)</span>
mailserver <span class="op">=</span> smtplib.SMTP(<span class="st">&#39;smtp.gmail.com:587&#39;</span>)
mailserver.ehlo()
mailserver.starttls()
mailserver.login(sender, password)
mailserver.sendmail(sender, [destination], msg.as_string())
mailserver.quit()
<span class="bu">print</span> <span class="st">&#39;send email success&#39;</span></code></pre></div></li>
<li><p>Multi-core and multi-thread processing</p>
<p>Python　是解释型的语言,而　Python　解释器使用　GIL(全局解 释器锁)来在内部禁止并行执行,正是这个　GIL　限制你在多核处理器上同一时间也只能执行一条字节码指令. <a href="http://www.parallelpython.com/">Parallel Python</a> 这个库,正是为支持<span style="color:red">smp 多路多核多　cpu</span>而设计的, 而且它不仅可以多核处理器协同工作,还可以通过网络集群运行。</p></li>
<li><p>pp 模块的简介 PP 是一个　Python　模块，提供了在 SMP(多 CPU 或多核)和集群(通过网络连接的多台计算机)上并行执行 Python 代码的机制。轻量级，易于安装，并 集成了其他软件。PP 也是一个用纯 Python 代码实现的跨平台，开放源码模块. 并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#-*- coding: UTF-8 -*-</span>
<span class="im">import</span> math, sys, time
<span class="im">import</span> pp
<span class="kw">def</span> IsPrime(n):
    <span class="co">&quot;&quot;&quot;返回 n 是否是素数&quot;&quot;&quot;</span>
    <span class="cf">if</span> <span class="op">not</span> <span class="bu">isinstance</span>(n, <span class="bu">int</span>):
        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">&quot;argument passed to is_prime is not of &#39;int&#39; type&quot;</span>)
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:
        <span class="cf">return</span> <span class="va">False</span>
    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:
        <span class="cf">return</span> <span class="va">True</span>
    <span class="bu">max</span> <span class="op">=</span> <span class="bu">int</span>(math.ceil(math.sqrt(n)))
    i <span class="op">=</span> <span class="dv">2</span>
    <span class="cf">while</span> i <span class="op">&lt;=</span> <span class="bu">max</span>:
        <span class="cf">if</span> n <span class="op">%</span> i <span class="op">==</span> <span class="dv">0</span>:
            <span class="cf">return</span> <span class="va">False</span>
        i <span class="op">+=</span> <span class="dv">1</span>
    <span class="cf">return</span> <span class="va">True</span>
<span class="kw">def</span> SumPrimes(n):
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">xrange</span>(<span class="dv">15</span>):
        <span class="bu">sum</span>([x <span class="cf">for</span> x <span class="op">in</span> <span class="bu">xrange</span>(<span class="dv">2</span>,n) <span class="cf">if</span> IsPrime(x)])
    <span class="co">&quot;&quot;&quot;计算从 2-n 之间的所有素数之和&quot;&quot;&quot;</span>
    <span class="cf">return</span> <span class="bu">sum</span>([x <span class="cf">for</span> x <span class="op">in</span> <span class="bu">xrange</span>(<span class="dv">2</span>,n) <span class="cf">if</span> IsPrime(x)])
inputs <span class="op">=</span> (<span class="dv">100000</span>, <span class="dv">100100</span>, <span class="dv">100200</span>, <span class="dv">100300</span>, <span class="dv">100400</span>, <span class="dv">100500</span>, <span class="dv">100600</span>, <span class="dv">100700</span>)
start_time <span class="op">=</span> time.time()
<span class="cf">for</span> <span class="bu">input</span> <span class="op">in</span> inputs:
    <span class="bu">print</span> SumPrimes(<span class="bu">input</span>)
<span class="bu">print</span> <span class="st">&#39;单线程执行，总耗时&#39;</span>, time.time() <span class="op">-</span> start_time, <span class="st">&#39;s&#39;</span>
<span class="co"># tuple of all parallel python servers to connect with</span>
ppservers <span class="op">=</span> ()
<span class="co">#ppservers = (&quot;10.0.0.1&quot;,)</span>
<span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">&gt;</span> <span class="dv">1</span>:
    ncpus <span class="op">=</span> <span class="bu">int</span>(sys.argv[<span class="dv">1</span>])
    <span class="co"># Creates jobserver with ncpus workers</span>
    job_server <span class="op">=</span> pp.Server(ncpus, ppservers<span class="op">=</span>ppservers)
<span class="cf">else</span>:
    <span class="co"># Creates jobserver with automatically detected number of workers</span>
    job_server <span class="op">=</span> pp.Server(ppservers<span class="op">=</span>ppservers)
<span class="bu">print</span> <span class="st">&quot;pp 可以用的工作核心线程数&quot;</span>, job_server.get_ncpus(), <span class="st">&quot;workers&quot;</span>
start_time <span class="op">=</span> time.time()
jobs <span class="op">=</span> [(<span class="bu">input</span>, job_server.submit(SumPrimes,(<span class="bu">input</span>,), (IsPrime,), (<span class="st">&quot;math&quot;</span>,))) <span class="cf">for</span> <span class="bu">input</span> <span class="op">in</span> inputs]
<span class="cf">for</span> <span class="bu">input</span>, job <span class="op">in</span> jobs:
    <span class="bu">print</span> <span class="st">&quot;Sum of primes below&quot;</span>, <span class="bu">input</span>, <span class="st">&quot;is&quot;</span>, job()
<span class="bu">print</span> <span class="st">&quot;多线程下执行耗时: &quot;</span>, time.time() <span class="op">-</span> start_time, <span class="st">&quot;s&quot;</span>
job_server.print_stats()</code></pre></div>
<p><span style="color:red"><strong>Reference:</strong></span> <a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000">Python 2.7教程</a> / <a href="http://wiki.jikexueyuan.com/project/python-actual-combat/tutorial-25.html">Parallel Python 实现程序的并行多 cpu 多核利用</a> / <a href="http://stackoverflow.com/questions/1546429/parallel-python-how-do-i-supply-arguments-to-submit">Parallel Python: How do I supply arguments to 'submit'?</a></p></li>
<li><p>Programming with c/c++<br/></p>
<p>The objective is to make available to python a C++ function that takes a matrix in form of a 2D STL vector and returns an average of each row (as a 1D STL vector).The code in C++ (&quot;code.cpp&quot;) is as follow:<br/></p>
<pre><code>#include &lt;vector&gt;
#include &quot;code.h&quot;

using namespace std;

vector&lt;double&gt; average (vector&lt; vector&lt;double&gt; &gt; i_matrix) {
  // compute average of each row..
  vector &lt;double&gt; averages;
  for (int r = 0; r &lt; i_matrix.size(); r++){
    double rsum = 0.0;
    double ncols= i_matrix[r].size();
    for (int c = 0; c&lt; i_matrix[r].size(); c++){
      rsum += i_matrix[r][c];
    }
    averages.push_back(rsum/ncols);
  }
  return averages;
}</code></pre>
<ul>
<li>The equivalent header (&quot;code.h&quot;) is:<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#ifndef _code</span>
<span class="ot">#define _code</span>

<span class="ot">#include &lt;vector&gt;</span>

std::vector&lt;<span class="dt">double</span>&gt; average (std::vector&lt; std::vector&lt;<span class="dt">double</span>&gt; &gt; i_matrix);

<span class="ot">#endif</span></code></pre></div>
<ul>
<li>We first compile the C++ code to create an object file:<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">g++</span> -c -fPIC code.cpp</code></pre></div>
<ul>
<li>We then define a swig interface definition file (&quot;code.i&quot;) for our C++ functions.<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">%module code
%{
<span class="ot">#include &quot;code.h&quot;</span>
%}
%include <span class="st">&quot;std_vector.i&quot;</span>
<span class="kw">namespace</span> std {
  <span class="co">/* On a side note, the names VecDouble and VecVecdouble can be changed, but the order of first the inner vector matters !*/</span>
  %<span class="kw">template</span>(VecDouble) vector&lt;<span class="dt">double</span>&gt;;
  %<span class="kw">template</span>(VecVecdouble) vector&lt; vector&lt;<span class="dt">double</span>&gt; &gt;;
}

%include <span class="st">&quot;code.h&quot;</span></code></pre></div>
<ul>
<li>Using swig, we generate a C++ interface source code from the swig interface definition file..<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">swig</span> -c++ -python code.i</code></pre></div>
<ul>
<li>We finally compile the generated C++ interface source file and link everything together to generate a shared library that is directly importable by python (the &quot;_&quot; matters):<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">g++</span> -c -fPIC code_wrap.cxx  -I/usr/include/python2.7 -I/usr/lib/python2.7
<span class="kw">g++</span> -shared -Wl,-soname,_code.so -o _code.so code.o code_wrap.o</code></pre></div>
<ul>
<li>We can now use the function in python scripts:<br/></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#!/usr/bin/env python</span>

<span class="im">import</span> code
a<span class="op">=</span> [[<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>],[<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>]]
<span class="bu">print</span> a
b <span class="op">=</span> code.average(a)
<span class="bu">print</span> <span class="st">&quot;Assignment done&quot;</span>
<span class="bu">print</span> a
<span class="bu">print</span> b</code></pre></div></li>
</ol>
<h1 id="installing-packages">Installing packages</h1>
<p>Many packages can be installed via anaconda(strongly recommend).</p>
<ol style="list-style-type: decimal">
<li><p>NumPy ans SciPy<br/> The SciPy library, a collection of numerical algorithms and domain-specific toolboxes, including signal processing, optimization, statistics and much more.<br/> NumPy, the fundamental package for numerical computation. It defines the numerical array and matrix types and basic operations on them.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> pip install numpy
<span class="kw">sudo</span> pip install scipy</code></pre></div></li>
<li><p>Matplotlib<br/> Matplotlib, a mature and popular plotting package, that provides publication-quality 2D plotting as well as rudimentary 3D plotting.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> pip install matplotlib   OR  sudo apt-get install python-matplotlib
<span class="kw">sudo</span> pip install -U scikit-learn
<span class="kw">sudo</span> pip install pandas</code></pre></div></li>
<li><p>PIL<br/> The Python Imaging Library (PIL) adds image processing capabilities to your Python interpreter. This library supports many file formats, and provides powerful image processing and graphics capabilities.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install Pillow
<span class="kw">pip</span> install PIL --allow-external PIL --allow-unverified PIL</code></pre></div></li>
<li><p>LibSVM<br/> LIBSVM is an integrated software for support vector classification, (C-SVC, nu-SVC), regression (epsilon-SVR, nu-SVR) and distribution estimation (one-class SVM). It supports multi-class classification.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install -e git+https://github.com/Salinger/libsvm-python.git#egg=libsvm-python</code></pre></div></li>
<li><p>OpenCV<br/> Installing OpenCV is a bit different, depending on your operating system. <a href="http://gunheeleo.blogspot.sg/2013/07/install-opencv-without-root-permission.html">ref</a>, <a href="http://gunheeleo.blogspot.sg/2013/07/install-opencv-without-root-permission.html">ref</a><br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cmake</span> -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/home/jxgu/tool/lib/opencv3.0 -D BUILD_PYTHON_SUPPORT=ON -D PYTHON_EXECUTABLE=/home/jxgu/tool/lib/python-2.7.3/bin/python -D PYTHONINTERP_FOUND=1 ..</code></pre></div></li>
<li><p>VLFeat<br/> The VLFeat open source library implements popular computer vision algorithms specializing in image understanding and local features extraction and matching. Algorithms include Fisher Vector, VLAD, SIFT, MSER, k-means, hierarchical k-means, agglomerative information bottleneck, SLIC superpixels, quick shift superpixels, large scale SVM training, and many others.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install http://pypi.python.org/packages/source/p/pyvlfeat/pyvlfeat-0.1.1a3.tar.gz
<span class="kw">pip</span> install https://pypi.python.org/packages/source/v/vlfeat-ctypes/vlfeat-ctypes-0.1.4.tar.gz</code></pre></div></li>
<li><p>PyGame<br/> Pygame is a cross-platform set of Python modules designed for writing video games.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">sudo</span> apt-get install mercurial
<span class="kw">sudo</span> pip install hg+http://bitbucket.org/pygame/pygame</code></pre></div></li>
<li><p>PyOpenGL<br/> PyOpenGL is the most common cross platform Python binding to OpenGL and related APIs.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install PyOpenGL PyOpenGL_accelerate</code></pre></div></li>
<li><p>Pydot<br/> Python interface to Graphviz's Dot. Graphviz’s dot language Python interface. This module provides with a full interface to create handle modify and process graphs in Graphviz’s dot language.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> uninstall pyparsing
<span class="kw">pip</span> install -Iv https://pypi.python.org/packages/source/p/pyparsing/pyparsing-1.5.7.tar.gz
<span class="kw">pip</span> install pydot
<span class="kw">pip</span> install pydot2
<span class="kw">conda</span> install pydot</code></pre></div></li>
<li><p>Python-graph<br/> python-graph is a library for working with graphs in Python. This software provides ﻿a suitable data structure for representing graphs and a whole set of important algorithms.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install https://github.com/chapmanb/python-graph/releases/download/1.8.2/python-graph-core-1.8.2.tar.gz
<span class="kw">pip</span> install https://github.com/chapmanb/python-graph/releases/download/1.8.2/python-graph-dot-1.8.2.tar.gz
<span class="kw">conda</span> install -c https://conda.binstar.org/bcbio python-graph-core python-graph-dot</code></pre></div></li>
<li><p>Simplejson<br/> simplejson is a simple, fast, complete, correct and extensible JSON <a href="http://json.org" class="uri">http://json.org</a> encoder and decoder for Python 2.5+ and Python 3.3+.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install https://pypi.python.org/packages/source/s/simplejson/simplejson-3.8.1.tar.gz
<span class="kw">pip</span> install simplejson
<span class="kw">pip</span> install --upgrade simplejson</code></pre></div></li>
<li><p>PySQLite<br/> PySqlite is a Python binding for the ​SQLite light-weight database engine, which is Trac's default DatabaseBackend.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install pysqlite</code></pre></div></li>
<li><p>CherryPy<br/> CherryPy is a pythonic, object-oriented HTTP framework.<br/></p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">pip</span> install cherrypy</code></pre></div></li>
<li><p>Chainer<br/> <a href="https://github.com/pfnet/chainer">Chainer: a neural network framework</a></p></li>
<li><p>Theao<br/></p>
<ol style="list-style-type: decimal">
<li>Set device id<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">THEANO_FLAGS<span class="op">=</span><span class="st">&#39;floatX=float32,device=gpu0,nvcc.fastmath=True&#39;</span>  python <span class="op">&lt;</span>myscript<span class="op">&gt;</span>.py.
<span class="co"># http://deeplearning.net/software/theano/library/config.html.</span>
<span class="co"># If a value is defined several times in THEANO_FLAGS, the right-most definition is used. So, for instance, if THEANO_FLAGS=&#39;device=cpu,device=gpu0&#39;, then gpu0 will be used.</span></code></pre></div></li>
<li><p>ijson<br/> <a href="http://explique.me/Ijson/">Ijson gave us a magic level of memory-saving</a> # Image datasets</p></li>
<li>Flickr<br/> Flickr has an API for interfacing with the service that makes it possible to upload, download, and annotate images (and much more). API is <a href="http://flickr.com/services/api">here</a><br/></li>
<li>Panoramio<br/> Panoramio has an API to access content programmatically, API is <a href="http://www.panoramio.com/api/.">here</a><br/></li>
<li>Oxford Visual Geometry Group<br/> The Visual Geometry research group atOxford University has many datasets available at <a href="http://www.robots.ox.ac.uk/~vgg/data/">here</a>. <br/></li>
<li>University of Kentucky Recognition Benchmark Images<br/> The UK Benchmark image set, also called the “ukbench” set, is a setwith 2,550 groups of images, the data is available <a href="http://www.vis.uky.edu/~stewe/ukbench/">here</a>.<br/></li>
<li>Other<br/>
<ol style="list-style-type: decimal">
<li>Prague Texture Segmentation Datagenerator and Benchmark, <a href="http://mosaic.utia.cas.cz/index.php.">here</a>.<br/></li>
<li>MSR Cambridge Grab Cut Dataset, <a href="http://www.eecs.berkeley.edu/Research/Projects/CS/vision/grouping/segbench/">here</a>.<br/></li>
<li>Caltech 101, <a href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">here</a>.<br/></li>
<li>Static Hand Posture Database, <a href="http://www.idiap.ch/resource/gestures/">here</a>.<br/></li>
<li>Middlebury Stereo Datasets, <a href="http://vision.middlebury.edu/stereo/data/">here</a>.<br/></li>
</ol></li>
</ol>
<h1 id="contents">Contents</h1>
<h2 id="basic-image-handling-and-processing">Basic image handling and processing</h2>
<ol style="list-style-type: decimal">
<li><p>PIL- The Python Imaging Libaray<br/> The Python Imaging Library (PIL) provides general image handling and lots of useful basic image operations like resizing, cropping, rotating, color conversion and much more. <br/></p>
<ol style="list-style-type: decimal">
<li>Read images frommost formats. <br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;empire.jpg&#39;</span>)   <span class="co"># pil_im is a PIL image object.</span>
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>)  <span class="co"># read an image and convert it to grayscale</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Create a list of filenames of all images in a folder.<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> get_imlist(path):
<span class="co">&quot;&quot;&quot;    Returns a list of filenames for</span>
<span class="co">    all jpg images in a directory. &quot;&quot;&quot;</span>

<span class="cf">return</span> [os.path.join(path,f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.jpg&#39;</span>)]</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Convert Images to Another Format:<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">import</span> os
<span class="im">import</span> pickle

filelist <span class="op">=</span> get_imlist(<span class="st">&#39;../data/convert_images_format_test/&#39;</span>) <span class="co">#获取convert_images_format_test文件夹下的图片文件名(包括后缀名)</span>
imlist <span class="op">=</span> <span class="bu">file</span>(<span class="st">&#39;../data/convert_images_format_test/imlist.txt&#39;</span>,<span class="st">&#39;w&#39;</span>) <span class="co">#将获取的图片文件列表保存到imlist.txt中</span>
pickle.dump(filelist,imlist) <span class="co">#序列化</span>
imlist.close()

<span class="cf">for</span> infile <span class="op">in</span> filelist:
    outfile <span class="op">=</span> os.path.splitext(infile)[<span class="dv">0</span>] <span class="op">+</span> <span class="st">&quot;.png&quot;</span> <span class="co">#分离文件名与扩展名</span>
    <span class="cf">if</span> infile <span class="op">!=</span> outfile:
        <span class="cf">try</span>:
            Image.<span class="bu">open</span>(infile).save(outfile)
            <span class="bu">print</span> <span class="st">&quot;convert file :&quot;</span>, infile, <span class="st">&quot;save file&quot;</span>, outfile
        <span class="cf">except</span> <span class="pp">IOError</span>:
            <span class="bu">print</span> <span class="st">&quot;cannot convert&quot;</span>, infile</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Create Thumbnails:<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 缩略图</span>
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>)
size <span class="op">=</span> <span class="dv">128</span>, <span class="dv">128</span>
pil_im.thumbnail(size)
<span class="bu">print</span> pil_im.size
title(<span class="st">&#39;Thumbnail&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(pil_im)
pil_im.save(<span class="st">&#39;../images/ch01/thumbnail.jpg&#39;</span>) <span class="co">#保存缩略图</span></code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Copy and Paste Regions:<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">#拷贝粘贴区域</span>
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>)
box <span class="op">=</span> (<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">400</span>,<span class="dv">400</span>)
region <span class="op">=</span> pil_im.crop(box)
region <span class="op">=</span> region.transpose(Image.ROTATE_180)
pil_im.paste(region,box)
title(<span class="st">&#39;Copy and paste area&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(pil_im)</code></pre></div>
<ol start="6" style="list-style-type: decimal">
<li>Resize and Rotate<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># 调整图像尺寸</span>
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>)
pil_im <span class="op">=</span> pil_im.resize(size) <span class="co"># resize() with a tuple giving the new size</span>
<span class="bu">print</span> pil_im.size
title(<span class="st">&#39;Resized image&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(pil_im)

<span class="co"># 旋转图像45°</span>
pil_im <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>)
pil_im <span class="op">=</span> pil_im.rotate(<span class="dv">45</span>)  <span class="co"># To rotate an image, use counterclockwise angles</span>
title(<span class="st">&#39;Rotated image(45 degree)&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(pil_im)</code></pre></div></li>
<li><p>Matplotlib<br/></p>
<ol style="list-style-type: decimal">
<li>Plotting Images, Points, and Lines:<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>))
figure()

<span class="co"># 画有坐标轴的</span>
subplot(<span class="dv">121</span>)
imshow(im)
x <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">400</span>, <span class="dv">400</span>]
y <span class="op">=</span> [<span class="dv">200</span>, <span class="dv">500</span>, <span class="dv">200</span>, <span class="dv">500</span>]
<span class="co"># Color:&#39;b&#39;-blue; &#39;g&#39;-green; &#39;r&#39;-red; &#39;c&#39;-cyan; &#39;m&#39;-magenta; &#39;y&#39;-yellow; &#39;k&#39;-black; &#39;w&#39;-white</span>
<span class="co"># Line style: &#39;-&#39;-solid; &#39;- -&#39;-dashed; &#39;:&#39;-dotted.</span>
<span class="co"># Marker: &#39;.&#39;-point; &#39;o&#39;-circle; &#39;s&#39;-square; &#39;*&#39;-star; &#39;+&#39;-plus; &#39;x&#39;-x</span>
plot(x, y, <span class="st">&#39;r*&#39;</span>) <span class="co"># plot the points with red star-markers</span>
plot(x[:<span class="dv">2</span>], y[:<span class="dv">2</span>]) <span class="co"># line plot connecting the first two points</span>
title(<span class="st">&#39;Plooting: &quot;empire.jpg&quot;&#39;</span>)

<span class="co"># 不显示坐标轴</span>
subplot(<span class="dv">122</span>)
imshow(im)
x <span class="op">=</span> [<span class="dv">100</span>, <span class="dv">100</span>, <span class="dv">400</span>, <span class="dv">400</span>]
y <span class="op">=</span> [<span class="dv">200</span>, <span class="dv">500</span>, <span class="dv">200</span>, <span class="dv">500</span>]
plot(x, y, <span class="st">&#39;r*&#39;</span>)
plot(x[:<span class="dv">2</span>], y[:<span class="dv">2</span>])
axis(<span class="st">&#39;off&#39;</span>)  <span class="co">#显示坐标轴</span>
title(<span class="st">&#39;Plotting: &quot;empire.jpg&quot;&#39;</span>)

show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Visualizing image contours and plotting image histograms. An image histogram is a plot showing the distribution of pixel values. A number of bins is specified for the span of values and each bin gets a count of how many pixels have values in the bin’s range. The<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))  <span class="co"># 打开图像，并转成灰度图像(单色画)</span>

figure()
subplot(<span class="dv">121</span>)
gray() <span class="co"># Need grayscale images, because the contours need to be taken on a single value for every coordinate [x, y]</span>
contour(im, origin<span class="op">=</span><span class="st">&#39;image&#39;</span>)
axis(<span class="st">&#39;equal&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Image contour&#39;</span>)

subplot(<span class="dv">122</span>)
<span class="co"># converts any array to a one-dimensional array with values taken row-wise</span>
<span class="co"># hist() takes a one-dimensional array as input</span>
hist(im.flatten(), <span class="dv">128</span>)
title(<span class="st">&#39;Histogram&#39;</span>)
plt.xlim([<span class="dv">0</span>,<span class="dv">260</span>])
plt.ylim([<span class="dv">0</span>,<span class="dv">11000</span>])

show()</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Interactive Annotation<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>))
imshow(im)
<span class="bu">print</span> <span class="st">&#39;Please click 3 points&#39;</span>
imshow(im)
x <span class="op">=</span> ginput(<span class="dv">3</span>)
<span class="bu">print</span> <span class="st">&#39;You clicked:&#39;</span>, x

show()</code></pre></div></li>
<li><p>Numpy<br/> <a href="http://www.scipy.org/NumPy/">NumPy</a> is a package popularly used for scientific comput- ing with Python. It contains a number of useful concepts such as array objects (for representing vectors, matrices, images and much more) and linear algebra functions.<br/></p>
<ol style="list-style-type: decimal">
<li>Array Image Representation<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>))
<span class="bu">print</span> im.shape, im.dtype
<span class="co"># &#39;f&#39; is a short command for setting the type to floating point.</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>),<span class="st">&#39;f&#39;</span>)
<span class="bu">print</span> im.shape, im.dtype</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Elements access examples for a grayscale image<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">im[i,:] <span class="op">=</span> im[j,:]    <span class="co"># set the values of row i with values from row j</span>
im[:,i] <span class="op">=</span> <span class="dv">100</span>    <span class="co"># set all values in column i to 100</span>
im[:<span class="dv">100</span>,:<span class="dv">50</span>].<span class="bu">sum</span>()    <span class="co"># the sum of the values of the first 100 rows and 50 columns</span>
im[<span class="dv">50</span>:<span class="dv">100</span>,<span class="dv">50</span>:<span class="dv">100</span>]    <span class="co"># rows 50-100, columns 50-100 (100th not included)</span>
im[i].mean()    <span class="co"># average of row i</span>
im[:,<span class="op">-</span><span class="dv">1</span>]    <span class="co"># last column</span>
im[<span class="op">-</span><span class="dv">2</span>,:] (<span class="op">or</span> im[<span class="op">-</span><span class="dv">2</span>]) <span class="co"># second to last row</span></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Graylevel Transforms<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
<span class="bu">print</span> <span class="bu">int</span>(im.<span class="bu">min</span>()), <span class="bu">int</span>(im.<span class="bu">max</span>())

im2 <span class="op">=</span> <span class="dv">255</span> <span class="op">-</span> im  <span class="co"># invert image</span>
<span class="bu">print</span> <span class="bu">int</span>(im2.<span class="bu">min</span>()), <span class="bu">int</span>(im2.<span class="bu">max</span>())

im3 <span class="op">=</span> (<span class="fl">100.0</span><span class="op">/</span><span class="dv">255</span>) <span class="op">*</span> im <span class="op">+</span> <span class="dv">100</span>  <span class="co"># clamp to interval 100...200</span>
<span class="bu">print</span> <span class="bu">int</span>(im3.<span class="bu">min</span>()), <span class="bu">int</span>(im3.<span class="bu">max</span>())

im4 <span class="op">=</span> <span class="fl">255.0</span> <span class="op">*</span> (im<span class="op">/</span><span class="fl">255.0</span>)<span class="op">**</span><span class="dv">2</span>  <span class="co"># squared</span>
<span class="bu">print</span> <span class="bu">int</span>(im4.<span class="bu">min</span>()), <span class="bu">int</span>(im4.<span class="bu">max</span>())
<span class="co"># If you did some operation to change the type from “uint8” to another data type, such as im3 or im4 in the example above, you need to convert back before creating the PIL image</span>
im4 <span class="op">=</span> Image.fromarray(uint8(im4))

figure()
gray()
subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>)
imshow(im2)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="vs">r&#39;$f(x)=255-x$&#39;</span>)

subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)
imshow(im3)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="vs">r&#39;$f(x)=\frac</span><span class="sc">{100}{255}</span><span class="vs">x+100$&#39;</span>)

subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>)
imshow(im4)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="vs">r&#39;$f(x)=255(\frac</span><span class="sc">{x}{255}</span><span class="vs">)^2$&#39;</span>)
show()</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Image Resizing<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> imresize(im,sz):
    <span class="co">&quot;&quot;&quot; Resize an image array using PIL. &quot;&quot;&quot;</span>
    pil_im <span class="op">=</span> Image.fromarray(uint8(im))
    <span class="cf">return</span> array(pil_im.resize(sz))</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Histogram Equalization<nr/></li>
</ol>
<p>Histogram Equalization transform flattens the gray level histogram of an image so that all intensities are as equally common as possible. This is often a good way to normalize image intensity before further processing and also a way to increase image contrast.</p>
<p>The histogram equalization transform function is a <span style="color:red"><em>cumulative distribution function</em>(normalied to map the range of pixel values to the desired range).</span></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> histeq(im,nbr_bins<span class="op">=</span><span class="dv">256</span>):
    <span class="co">&quot;&quot;&quot; Histogram equalization of a grayscale image. &quot;&quot;&quot;</span>
    <span class="co"># get image histogram</span>
    imhist,bins <span class="op">=</span> histogram(im.flatten(),nbr_bins,normed<span class="op">=</span><span class="va">True</span>)
    cdf <span class="op">=</span> imhist.cumsum() <span class="co"># cumulative distribution function</span>
    cdf <span class="op">=</span> <span class="dv">255</span> <span class="op">*</span> cdf <span class="op">/</span> cdf[<span class="op">-</span><span class="dv">1</span>] <span class="co"># normalize</span>
    <span class="co"># use linear interpolation of cdf to find new pixel values</span>
    im2 <span class="op">=</span> interp(im.flatten(),bins[:<span class="op">-</span><span class="dv">1</span>],cdf)
    <span class="cf">return</span> im2.reshape(im.shape), cdf</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.tools <span class="im">import</span> imtools

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))  <span class="co"># 打开图像，并转成灰度图像</span>
im2, cdf <span class="op">=</span> imtools.histeq(im)

figure()
subplot(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span>)
axis(<span class="st">&#39;off&#39;</span>)
gray()
title(<span class="st">&#39;Raw image&#39;</span>)
imshow(im)

subplot(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Image after histogram equlization&#39;</span>)
imshow(im2)

subplot(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Raw histogram &#39;</span>)
<span class="co">#hist(im.flatten(), 128, cumulative=True, normed=True)</span>
hist(im.flatten(), <span class="dv">128</span>, normed<span class="op">=</span><span class="va">True</span>)

subplot(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Histogram after equlization&#39;</span>)
hist(im2.flatten(), <span class="dv">128</span>, normed<span class="op">=</span><span class="va">True</span>)

show()</code></pre></div>
<ol start="5" style="list-style-type: decimal">
<li>Averaging Images<br/> Averaging images is a simple way of <span style="color:red">reducing image noise</span> and is also often used for artistic effects.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> compute_average(imlist):
    <span class="co">&quot;&quot;&quot; Compute the average of a list of images. &quot;&quot;&quot;</span>
    <span class="co"># open first image and make into array of type float</span>
    averageim <span class="op">=</span> array(Image.<span class="bu">open</span>(imlist[<span class="dv">0</span>]), <span class="st">&#39;f&#39;</span>)
    <span class="cf">for</span> imname <span class="op">in</span> imlist[<span class="dv">1</span>:]:
        <span class="cf">try</span>:
            averageim <span class="op">+=</span> array(Image.<span class="bu">open</span>(imname))
        <span class="cf">except</span>:
            <span class="bu">print</span> imname <span class="op">+</span> <span class="st">&#39;...skipped&#39;</span>
            averageim <span class="op">/=</span> <span class="bu">len</span>(imlist)
        <span class="co"># return average as uint8</span>
        <span class="cf">return</span> array(averageim, <span class="st">&#39;uint8&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.tools <span class="im">import</span> imtools

filelist <span class="op">=</span> get_imlist(<span class="st">&#39;../data/avg/&#39;</span>) <span class="co">#获取convert_images_format_test文件夹下的图片文件名(包括后缀名)</span>
avg <span class="op">=</span> imtools.compute_average(filelist)

<span class="cf">for</span> impath <span class="op">in</span> filelist:
        im1 <span class="op">=</span> array(Image.<span class="bu">open</span>(impath))
        subplot(<span class="dv">2</span>, <span class="dv">2</span>, filelist.index(impath)<span class="op">+</span><span class="dv">1</span>)
        imshow(im1)
        imNum<span class="op">=</span><span class="bu">str</span>(filelist.index(impath)<span class="op">+</span><span class="dv">1</span>)
        title(<span class="st">&#39;Image need to be averaged&#39;</span><span class="op">+</span>imNum)
        axis(<span class="st">&#39;off&#39;</span>)
subplot(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>)
imshow(avg)
title(<span class="st">&#39;Image after averaged &#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)

show()</code></pre></div>
<ol start="6" style="list-style-type: decimal">
<li>PCA of Images<br/> Principal ComponentAnalysis (PCA) is a useful technique for dimensionality reduction and is optimal in the sense that it represents the variability of the training data with as few dimensions as possible.</li>
</ol>
<p>To apply PCA on image data, <span style="color:red">the images need to be converted to a one-dimensional vector</span> representation using, for example, <span style="color:red">NumPy’s flatten()</span> method. To find the principal components, singular value decom- position (SVD) is usually used.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>

<span class="kw">def</span> pca(X):
    <span class="co">&quot;&quot;&quot;    Principal Component Analysis</span>
<span class="co">        input: X, matrix with training data stored as flattened arrays in rows</span>
<span class="co">        return: projection matrix (with important dimensions first), variance and mean.</span>
<span class="co">    &quot;&quot;&quot;</span>
    <span class="co"># get dimensions</span>
    num_data,dim <span class="op">=</span> X.shape
    <span class="co"># center data</span>
    mean_X <span class="op">=</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>)
    X <span class="op">=</span> X <span class="op">-</span> mean_X
    <span class="cf">if</span> dim<span class="op">&gt;</span>num_data:
        <span class="co"># PCA - compact trick used</span>
        M <span class="op">=</span> dot(X,X.T) <span class="co"># covariance matrix</span>
        e,EV <span class="op">=</span> linalg.eigh(M) <span class="co"># eigenvalues and eigenvectors</span>
        tmp <span class="op">=</span> dot(X.T,EV).T <span class="co"># this is the compact trick</span>
        V <span class="op">=</span> tmp[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># reverse since last eigenvectors are the ones we want</span>
        S <span class="op">=</span> sqrt(e)[::<span class="op">-</span><span class="dv">1</span>] <span class="co"># reverse since eigenvalues are in increasing order</span>
        <span class="co"># range() takes an integer n and returns a list of integers 0 . . . (n−1).</span>
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(V.shape[<span class="dv">1</span>]):
            V[:,i] <span class="op">/=</span> S
    <span class="cf">else</span>:
        <span class="co"># PCA - SVD used</span>
        U,S,V <span class="op">=</span> linalg.svd(X)
        V <span class="op">=</span> V[:num_data] <span class="co"># only makes sense to return the first num_data</span>
    <span class="co"># return the projection matrix, the variance and the mean</span>
    <span class="cf">return</span> V,S,mean_X

<span class="kw">def</span> center(X):
    <span class="co">&quot;&quot;&quot;    Center the square matrix X (subtract col and row means). &quot;&quot;&quot;</span>
    n,m <span class="op">=</span> X.shape
    <span class="cf">if</span> n <span class="op">!=</span> m:
        <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;Matrix is not square.&#39;</span>)
    colsum <span class="op">=</span> X.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> n
    rowsum <span class="op">=</span> X.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>) <span class="op">/</span> n
    totalsum <span class="op">=</span> X.<span class="bu">sum</span>() <span class="op">/</span> (n<span class="op">**</span><span class="dv">2</span>)
    <span class="co">#center</span>
    Y <span class="op">=</span> array([[ X[i,j]<span class="op">-</span>rowsum[i]<span class="op">-</span>colsum[j]<span class="op">+</span>totalsum <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(n) ] <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(n)])
    <span class="cf">return</span> Y</code></pre></div>
<p>This function first centers the data by subtracting the mean in each dimension. Then the eigenvectors corresponding to the largest eigenvalues of the covariance matrix are computed, either using a compact trick or using SVD.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.tools <span class="im">import</span> imtools, pca

<span class="co"># 获取图像列表和他们的尺寸</span>
imlist <span class="op">=</span> imtools.get_imlist(<span class="st">&#39;../data/fontimages/a_thumbs&#39;</span>)  <span class="co"># fontimages.zip is part of the book data set</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(imlist[<span class="dv">0</span>]))  <span class="co"># open one image to get the size</span>
m, n <span class="op">=</span> im.shape[:<span class="dv">2</span>]  <span class="co"># get the size of the images</span>
imnbr <span class="op">=</span> <span class="bu">len</span>(imlist)  <span class="co"># get the number of images</span>
<span class="bu">print</span> <span class="st">&quot;The number of images is </span><span class="sc">%d</span><span class="st">&quot;</span> <span class="op">%</span> imnbr

<span class="co"># Create matrix to store all flattened images</span>
immatrix <span class="op">=</span> array([array(Image.<span class="bu">open</span>(imname)).flatten() <span class="cf">for</span> imname <span class="op">in</span> imlist], <span class="st">&#39;f&#39;</span>)

<span class="co"># PCA降维, V:projection matrix, S:covariance matrix</span>
V, S, immean <span class="op">=</span> pca.pca(immatrix)

<span class="co"># 保存均值和主成分</span>
f <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;../data/fontimages/font_pca_modes.pkl&#39;</span>, <span class="st">&#39;wb&#39;</span>)
pickle.dump(immean,f)
pickle.dump(V,f)
f.close()

<span class="co"># Show the images (mean and 7 first modes)</span>
<span class="co"># This gives figure 1-8 (p15) in the book.</span>
figure()
gray()
subplot(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(immean.reshape(m, n))
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">7</span>):
   subplot(<span class="dv">2</span>, <span class="dv">4</span>, i<span class="dv">+2</span>)
   imshow(V[i].reshape(m, n))
   axis(<span class="st">&#39;off&#39;</span>)
show()</code></pre></div>
<ol start="7" style="list-style-type: decimal">
<li>Using the Pickle Module<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># save mean and principal components</span>
f <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;font_pca_modes.pkl&#39;</span>, <span class="st">&#39;wb&#39;</span>)
pickle.dump(immean,f)
pickle.dump(V,f)
f.close()

<span class="co"># load mean and principal components</span>
f <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;font_pca_modes.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>)
immean <span class="op">=</span> pickle.load(f)
V <span class="op">=</span> pickle.load(f)
f.close()

<span class="co"># The following are very useful construct.</span>
<span class="co"># open file and save</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;font_pca_modes.pkl&#39;</span>, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> f:
    pickle.dump(immean,f)
    pickle.dump(V,f)

<span class="co"># open file and load</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;font_pca_modes.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    immean <span class="op">=</span> pickle.load(f)
    V <span class="op">=</span> pickle.load(f)

<span class="co"># To save an array x to file, use:</span>
savetxt(<span class="st">&#39;test.txt&#39;</span>,x,<span class="st">&#39;</span><span class="sc">%i</span><span class="st">&#39;</span>)

<span class="co"># reading text:</span>
x <span class="op">=</span> loadtxt(<span class="st">&#39;test.txt&#39;</span>)</code></pre></div></li>
<li>Scipy<br/>
<ol style="list-style-type: decimal">
<li>Blurring Images<br/> A classic and very useful example of image convolution is Gaussian blurring of images. In essence, the (grayscale) image I is convolved with a Gaussian kernel to create a blurred version: <span class="math inline">\(I_{\delta}=I * G_{\delta}\)</span>, where <span class="math inline">\(*\)</span> indicates convolution and <span class="math inline">\(G_{\delta}\)</span> is a Gaussian 2D-kernel with standard deviation $$ defined as: <span class="math inline">\(G_{\delta} =\frac{1}{2\pi \delta} exp(-(x^2+y^2)/2\delta^2)\)</span><br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy.ndimage <span class="im">import</span> filters

<span class="co">#im = array(Image.open(&#39;board.jpeg&#39;))</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))

figure()
gray()
axis(<span class="st">&#39;off&#39;</span>)
subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Raw image&#39;</span>)
imshow(im)

<span class="cf">for</span> bi, blur <span class="op">in</span> <span class="bu">enumerate</span>([<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>]):
 im2 <span class="op">=</span> zeros(im.shape)
 im2 <span class="op">=</span> filters.gaussian_filter(im, blur)
 im2 <span class="op">=</span> np.uint8(im2)
 imNum<span class="op">=</span><span class="bu">str</span>(blur)
 subplot(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span> <span class="op">+</span> bi)
 axis(<span class="st">&#39;off&#39;</span>)
 title(<span class="st">&#39;Standard deviation&#39;</span><span class="op">+</span>imNum)
 imshow(im2)

<span class="co">#如果是彩色图像，则分别对三个通道进行模糊</span>
<span class="co">#for bi, blur in enumerate([2, 5, 10]):</span>
<span class="co">#  im2 = zeros(im.shape)</span>
<span class="co">#  for i in range(3):</span>
<span class="co">#    im2[:, :, i] = filters.gaussian_filter(im[:, :, i], blur)</span>
<span class="co">#  im2 = np.uint8(im2)</span>
<span class="co">#  subplot(1, 4,  2 + bi)</span>
<span class="co">#  axis(&#39;off&#39;)</span>
<span class="co">#  imshow(im2)</span>

show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Image Derivatives<br/> How the image intensity changes over the image is important information and is used for many applications. The intensity change is described with the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> derivatives <span class="math inline">\(I_x\)</span> and <span class="math inline">\(I_y\)</span> of the graylevel image <span class="math inline">\(I\)</span> (for color images, derivatives are usually taken for each color channel). <br/> The iamge gradient is the vector $ I = [I_x, I_y]^T $. The gradient has two important properties, the gradient magnitude: <span class="math inline">\(|\nabla I|=\sqrt{I_x^2+I_y^2}\)</span>, which describes how strong the image intensity change is, and the gradient angle: <span class="math inline">\(\alpha = arctan2(I_y,I_x)\)</span>, which indicates the direction of largest intensity change at each point(pixel) in the image.<br/> To be more robust to image noise and to compute derivatives at any scale, Gaussian derivative filters can be used:<span class="math inline">\(I_x=I*G_{\delta x}, I_y=I*G_{\delta y}\)</span> <br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy.ndimage <span class="im">import</span> filters
<span class="im">import</span> numpy

<span class="kw">def</span> imx(im, sigma):
   imgx <span class="op">=</span> zeros(im.shape)
   filters.gaussian_filter(im, sigma, (<span class="dv">0</span>, <span class="dv">1</span>), imgx)
   <span class="cf">return</span> imgx


<span class="kw">def</span> imy(im, sigma):
   imgy <span class="op">=</span> zeros(im.shape)
   filters.gaussian_filter(im, sigma, (<span class="dv">1</span>, <span class="dv">0</span>), imgy)
   <span class="cf">return</span> imgy


<span class="kw">def</span> mag(im, sigma):
   <span class="co"># there&#39;s also gaussian_gradient_magnitude()</span>
   <span class="co">#mag = numpy.sqrt(imgx**2 + imgy**2)</span>
   imgmag <span class="op">=</span> <span class="dv">255</span> <span class="op">-</span> numpy.sqrt(imgx <span class="op">**</span> <span class="dv">2</span> <span class="op">+</span> imgy <span class="op">**</span> <span class="dv">2</span>)
   <span class="cf">return</span> imgmag


im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
figure()
gray()

sigma <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>]

<span class="cf">for</span> i <span class="op">in</span>  sigma:
   subplot(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span>(sigma.index(i))<span class="op">+</span><span class="dv">1</span>)
   axis(<span class="st">&#39;off&#39;</span>)
   imshow(im)
   imgx<span class="op">=</span>imx(im, i)
   subplot(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span>(sigma.index(i))<span class="op">+</span><span class="dv">2</span>)
   axis(<span class="st">&#39;off&#39;</span>)
   imshow(imgx)
   imgy<span class="op">=</span>imy(im, i)
   subplot(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span>(sigma.index(i))<span class="op">+</span><span class="dv">3</span>)
   axis(<span class="st">&#39;off&#39;</span>)
   imshow(imgy)
   imgmag<span class="op">=</span>mag(im, i)
   subplot(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span><span class="op">*</span>(sigma.index(i))<span class="op">+</span><span class="dv">4</span>)
   axis(<span class="st">&#39;off&#39;</span>)
   imshow(imgmag)
show()</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Morphology—Counting Objects<br/> Morphology (or mathematical morphology) is a framework and a collection of image processing methods for measuring and analyzing basic shapes.<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy.ndimage <span class="im">import</span> measurements, morphology
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

<span class="co">&quot;&quot;&quot;   This is the morphology counting objects example in Section 1.4.  &quot;&quot;&quot;</span>

figure()
gray()
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/houses.png&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))<span class="co"># load image and threshold to make sure it is binary</span>
subplot(<span class="dv">221</span>)
imshow(im)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Raw image&#39;</span>)
im <span class="op">=</span> (im <span class="op">&lt;</span> <span class="dv">128</span>)

labels, nbr_objects <span class="op">=</span> measurements.label(im)
<span class="bu">print</span> <span class="st">&quot;Number of objects:&quot;</span>, nbr_objects
subplot(<span class="dv">222</span>)
imshow(labels)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Labeled image&#39;</span>)

im_open <span class="op">=</span> morphology.binary_opening(im, ones((<span class="dv">9</span>, <span class="dv">5</span>)), iterations<span class="op">=</span><span class="dv">2</span>)<span class="co"># morphology - opening to separate objects better</span>
subplot(<span class="dv">223</span>)
imshow(im_open)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Image after binary opening&#39;</span>)

labels_open, nbr_objects_open <span class="op">=</span> measurements.label(im_open)
<span class="bu">print</span> <span class="st">&quot;Number of objects:&quot;</span>, nbr_objects_open
subplot(<span class="dv">224</span>)
imshow(labels_open)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Image after binary opening and labled&#39;</span>)

show()</code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Using SciPy modules<br/> SciPy comes with some useful modules for input and output. Two of them are io and misc.<br/></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li>Reading and writing .mat files<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data <span class="op">=</span> scipy.io.loadmat(<span class="st">&#39;test.mat&#39;</span>)</code></pre></div>
<ol start="2" style="list-style-type: lower-alpha">
<li>Saving arrays as images<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data <span class="op">=</span> {}
data[<span class="st">&#39;x&#39;</span>] <span class="op">=</span> x
scipy.io.savemat(<span class="st">&#39;test.mat&#39;</span>,data)</code></pre></div>
<ol start="3" style="list-style-type: lower-alpha">
<li>Saving arrays as images<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.misc <span class="im">import</span> imsave
imsave(<span class="st">&#39;test.jpg&#39;</span>,im)</code></pre></div></li>
<li><p>Advances Example: Image De-Noising<br/></p>
<p>Rudin-Osher-Fatemi de-noising model (ROF) has the interesting property that it finds a smoother version of the image while preserving edges and structures.<br/> The total variation(TV) of a (grayscale) image <span class="math inline">\(I\)</span> is defined as the sum of the gradient norm. In a continuous representation, this is <span class="math inline">\(J(I)=\int | \nabla I | dx\)</span>. In a discrete setting, the total variation becomes: $J(I)=_{X} | I | $. where the sum is taken over all image coordinates <span class="math inline">\(X=[x,y]\)</span>.<br/> In the Chambolle version of ROF, the goal is to find a de-noised image <span class="math inline">\(U\)</span> that minimizes: <span class="math inline">\(min_u ||I-U||^2+2\lambda J(U)\)</span> <br/> where the norm $ ||I-U||$ meaures the difference between <span class="math inline">\(U\)</span> and the original image <span class="math inline">\(I\)</span>. What this means is, in essence, that the model looks for images that are “flat” but allows “jumps” at edges between regions.<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> numpy <span class="im">import</span> random
<span class="im">from</span> scipy.ndimage <span class="im">import</span> filters
<span class="im">from</span> scipy.misc <span class="im">import</span> imsave
<span class="im">from</span> PCV.tools <span class="im">import</span> rof

<span class="co">&quot;&quot;&quot; This is the de-noising example using ROF in Section 1.5. &quot;&quot;&quot;</span>

<span class="co"># create synthetic image with noise</span>
im <span class="op">=</span> zeros((<span class="dv">500</span>,<span class="dv">500</span>))
im[<span class="dv">100</span>:<span class="dv">400</span>,<span class="dv">100</span>:<span class="dv">400</span>] <span class="op">=</span> <span class="dv">128</span>
im[<span class="dv">200</span>:<span class="dv">300</span>,<span class="dv">200</span>:<span class="dv">300</span>] <span class="op">=</span> <span class="dv">255</span>
im <span class="op">=</span> im <span class="op">+</span> <span class="dv">30</span><span class="op">*</span>random.standard_normal((<span class="dv">500</span>,<span class="dv">500</span>))

U,T <span class="op">=</span> rof.denoise(im,im)
G <span class="op">=</span> filters.gaussian_filter(im,<span class="dv">10</span>)

<span class="co"># save the result</span>
<span class="co">#imsave(&#39;synth_original.pdf&#39;,im)</span>
<span class="co">#imsave(&#39;synth_rof.pdf&#39;,U)</span>
<span class="co">#imsave(&#39;synth_gaussian.pdf&#39;,G)</span>

<span class="co"># plot</span>
figure()
gray()

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>)
imshow(im)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;原噪声图像&#39;</span>)

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>)
imshow(G)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;高斯模糊后的图像&#39;</span>)

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>)
imshow(U)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;ROF降噪后的图像&#39;</span>)

show()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> numpy <span class="im">import</span> random
<span class="im">from</span> scipy.ndimage <span class="im">import</span> filters
<span class="im">from</span> scipy.misc <span class="im">import</span> imsave
<span class="im">from</span> PCV.tools <span class="im">import</span> rof

<span class="co">&quot;&quot;&quot; This is the de-noising example using ROF in Section 1.5. &quot;&quot;&quot;</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))

U,T <span class="op">=</span> rof.denoise(im,im)
G <span class="op">=</span> filters.gaussian_filter(im,<span class="dv">10</span>)

<span class="co"># save the result</span>
<span class="co">#imsave(&#39;synth_original.pdf&#39;,im)</span>
<span class="co">#imsave(&#39;synth_rof.pdf&#39;,U)</span>
<span class="co">#imsave(&#39;synth_gaussian.pdf&#39;,G)</span>

<span class="co"># plot</span>
figure()
gray()

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>)
imshow(im)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;原噪声图像&#39;</span>)

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">2</span>)
imshow(G)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;高斯模糊后的图像&#39;</span>)

subplot(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">3</span>)
imshow(U)
<span class="co">#axis(&#39;equal&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;ROF降噪后的图像&#39;</span>)

show()</code></pre></div></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="local-image-descriptors">Local image descriptors</h2>
<ol style="list-style-type: decimal">
<li><p>Harris corner detector<br/></p>
<ol style="list-style-type: decimal">
<li>Corner detection with the Harris corner detector<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> harris
<span class="co">&quot;&quot;&quot; Example of detecting Harris corner points (Figure 2-1 in the book).  &quot;&quot;&quot;</span>
<span class="co"># 读入图像</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
<span class="co"># 检测harris角点</span>
harrisim <span class="op">=</span> harris.compute_harris_response(im)
<span class="co"># Harris响应函数</span>
harrisim1 <span class="op">=</span> <span class="dv">255</span> <span class="op">-</span> harrisim
figure()
gray()
<span class="co">#画出Harris响应图</span>
subplot(<span class="dv">141</span>)
imshow(harrisim1)
<span class="bu">print</span> harrisim1.shape
axis(<span class="st">&#39;off&#39;</span>)
axis(<span class="st">&#39;equal&#39;</span>)

threshold <span class="op">=</span> [<span class="fl">0.01</span>, <span class="fl">0.05</span>, <span class="fl">0.1</span>]
<span class="cf">for</span> i, thres <span class="op">in</span> <span class="bu">enumerate</span>(threshold):
    filtered_coords <span class="op">=</span> harris.get_harris_points(harrisim, <span class="dv">6</span>, thres)
    subplot(<span class="dv">1</span>, <span class="dv">4</span>, i<span class="dv">+2</span>)
    imshow(im)
    <span class="bu">print</span> im.shape
    plot([p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="op">in</span> filtered_coords], [p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="op">in</span> filtered_coords], <span class="st">&#39;*&#39;</span>)
    axis(<span class="st">&#39;off&#39;</span>)
<span class="co">#原书采用的PCV中PCV harris模块</span>
<span class="co">#harris.plot_harris_points(im, filtered_coords)</span>
<span class="co"># plot only 200 strongest</span>
<span class="co"># harris.plot_harris_points(im, filtered_coords[:200])</span>
show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Finding corresponding points between images<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image

<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> harris
<span class="im">from</span> PCV.tools.imtools <span class="im">import</span> imresize

<span class="co">&quot;&quot;&quot;</span>
<span class="co">This is the Harris point matching example in Figure 2-2.</span>
<span class="co">&quot;&quot;&quot;</span>

<span class="co"># Figure 2-2上面的图</span>
<span class="co">#im1 = array(Image.open(&quot;../data/crans_1_small.jpg&quot;).convert(&quot;L&quot;))</span>
<span class="co">#im2 = array(Image.open(&quot;../data/crans_2_small.jpg&quot;).convert(&quot;L&quot;))</span>

<span class="co"># Figure 2-2下面的图</span>
im1 <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&quot;../data/sf_view1.jpg&quot;</span>).convert(<span class="st">&quot;L&quot;</span>))
im2 <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&quot;../data/sf_view2.jpg&quot;</span>).convert(<span class="st">&quot;L&quot;</span>))

<span class="co"># resize to make matching faster</span>
im1 <span class="op">=</span> imresize(im1, (im1.shape[<span class="dv">1</span>]<span class="op">/</span><span class="dv">2</span>, im1.shape[<span class="dv">0</span>]<span class="op">/</span><span class="dv">2</span>))
im2 <span class="op">=</span> imresize(im2, (im2.shape[<span class="dv">1</span>]<span class="op">/</span><span class="dv">2</span>, im2.shape[<span class="dv">0</span>]<span class="op">/</span><span class="dv">2</span>))

wid <span class="op">=</span> <span class="dv">5</span>
harrisim <span class="op">=</span> harris.compute_harris_response(im1, <span class="dv">5</span>)
filtered_coords1 <span class="op">=</span> harris.get_harris_points(harrisim, wid<span class="dv">+1</span>)
d1 <span class="op">=</span> harris.get_descriptors(im1, filtered_coords1, wid)

harrisim <span class="op">=</span> harris.compute_harris_response(im2, <span class="dv">5</span>)
filtered_coords2 <span class="op">=</span> harris.get_harris_points(harrisim, wid<span class="dv">+1</span>)
d2 <span class="op">=</span> harris.get_descriptors(im2, filtered_coords2, wid)

<span class="bu">print</span> <span class="st">&#39;starting matching&#39;</span>
matches <span class="op">=</span> harris.match_twosided(d1, d2)

figure()
gray()
harris.plot_matches(im1, im2, filtered_coords1, filtered_coords2, matches)
show()</code></pre></div></li>
<li><p>SIFT- Scale-Invariant Feature Transform<br/></p>
<ol style="list-style-type: decimal">
<li>Detecting interest points<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> harris

imname <span class="op">=</span> <span class="st">&#39;../data/empire.jpg&#39;</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(imname).convert(<span class="st">&#39;L&#39;</span>))
sift.process_image(imname, <span class="st">&#39;empire.sift&#39;</span>)
l1, d1 <span class="op">=</span> sift.read_features_from_file(<span class="st">&#39;empire.sift&#39;</span>)

figure()
gray()
subplot(<span class="dv">131</span>)
sift.plot_features(im, l1, circle<span class="op">=</span><span class="va">False</span>)
title(<span class="st">&#39;SIFT feature&#39;</span>)
subplot(<span class="dv">132</span>)
sift.plot_features(im, l1, circle<span class="op">=</span><span class="va">True</span>)
title(<span class="st">&#39;Use circular represent SIFT feature dimension&#39;</span>)

<span class="co"># 检测harris角点</span>
harrisim <span class="op">=</span> harris.compute_harris_response(im)

subplot(<span class="dv">133</span>)
filtered_coords <span class="op">=</span> harris.get_harris_points(harrisim, <span class="dv">6</span>, <span class="fl">0.1</span>)
imshow(im)
plot([p[<span class="dv">1</span>] <span class="cf">for</span> p <span class="op">in</span> filtered_coords], [p[<span class="dv">0</span>] <span class="cf">for</span> p <span class="op">in</span> filtered_coords], <span class="st">&#39;*&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
title(<span class="st">&#39;Harris points&#39;</span>)
show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Matching Descriptors<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">import</span> sys
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift


<span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">&gt;=</span> <span class="dv">3</span>:
  im1f, im2f <span class="op">=</span> sys.argv[<span class="dv">1</span>], sys.argv[<span class="dv">2</span>]
<span class="cf">else</span>:
  im1f <span class="op">=</span> <span class="st">&#39;../data/sf_view1.jpg&#39;</span>
  im2f <span class="op">=</span> <span class="st">&#39;../data/sf_view2.jpg&#39;</span>
<span class="co">#  im1f = &#39;../data/crans_1_small.jpg&#39;</span>
<span class="co">#  im2f = &#39;../data/crans_2_small.jpg&#39;</span>
<span class="co">#  im1f = &#39;../data/climbing_1_small.jpg&#39;</span>
<span class="co">#  im2f = &#39;../data/climbing_2_small.jpg&#39;</span>
im1 <span class="op">=</span> array(Image.<span class="bu">open</span>(im1f))
im2 <span class="op">=</span> array(Image.<span class="bu">open</span>(im2f))

<span class="co">#sift.process_image(im1f, &#39;out_sift_1.txt&#39;)</span>
l1, d1 <span class="op">=</span> sift.read_features_from_file(<span class="st">&#39;out_sift_1.txt&#39;</span>)
figure()
gray()
subplot(<span class="dv">121</span>)
sift.plot_features(im1, l1, circle<span class="op">=</span><span class="va">False</span>)

<span class="co">#sift.process_image(im2f, &#39;out_sift_2.txt&#39;)</span>
l2, d2 <span class="op">=</span> sift.read_features_from_file(<span class="st">&#39;out_sift_2.txt&#39;</span>)
subplot(<span class="dv">122</span>)
sift.plot_features(im2, l2, circle<span class="op">=</span><span class="va">False</span>)

<span class="co">#matches = sift.match(d1, d2)</span>
matches <span class="op">=</span> sift.match_twosided(d1, d2)
<span class="bu">print</span> <span class="st">&#39;{} matches&#39;</span>.<span class="bu">format</span>(<span class="bu">len</span>(matches.nonzero()[<span class="dv">0</span>]))

figure()
gray()
sift.plot_matches(im1, im2, l1, l2, matches, show_below<span class="op">=</span><span class="va">True</span>)
show()</code></pre></div></li>
<li><p>Matching geotagged images<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pydot

g <span class="op">=</span> pydot.Dot(graph_type<span class="op">=</span><span class="st">&#39;graph&#39;</span>)

g.add_node(pydot.Node(<span class="bu">str</span>(<span class="dv">0</span>), fontcolor<span class="op">=</span><span class="st">&#39;transparent&#39;</span>))
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">5</span>):
  g.add_node(pydot.Node(<span class="bu">str</span>(i <span class="op">+</span> <span class="dv">1</span>)))
  g.add_edge(pydot.Edge(<span class="bu">str</span>(<span class="dv">0</span>), <span class="bu">str</span>(i <span class="op">+</span> <span class="dv">1</span>)))
  <span class="cf">for</span> j <span class="op">in</span> <span class="bu">range</span>(<span class="dv">5</span>):
    g.add_node(pydot.Node(<span class="bu">str</span>(j <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> <span class="st">&#39;0&#39;</span> <span class="op">+</span> <span class="bu">str</span>(i <span class="op">+</span> <span class="dv">1</span>)))
    g.add_edge(pydot.Edge(<span class="bu">str</span>(j <span class="op">+</span> <span class="dv">1</span>) <span class="op">+</span> <span class="st">&#39;0&#39;</span> <span class="op">+</span> <span class="bu">str</span>(i <span class="op">+</span> <span class="dv">1</span>), <span class="bu">str</span>(j <span class="op">+</span> <span class="dv">1</span>)))
g.write_png(<span class="st">&#39;../images/ch02/ch02_fig2-9_graph.png&#39;</span>, prog<span class="op">=</span><span class="st">&#39;neato&#39;</span>)</code></pre></div></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="image-to-image-mappings">Image to image mappings</h2>
<ol style="list-style-type: decimal">
<li>Homographies<br/> A homography is a 2D projective transformation that maps points in one plane to another. <br/>
<ol style="list-style-type: decimal">
<li>The Direct Linear Transformation Algorithm<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> H_from_points(fp,tp):
<span class="co">&quot;&quot;&quot; Find homography H, such that fp is mapped to tp</span>
<span class="co">    using the linear DLT method. Points are conditioned</span>
<span class="co">    automatically. &quot;&quot;&quot;</span>

<span class="cf">if</span> fp.shape <span class="op">!=</span> tp.shape:
    <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">&#39;number of points do not match&#39;</span>)

<span class="co"># condition points (important for numerical reasons)</span>
<span class="co"># --from points--</span>
m <span class="op">=</span> mean(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)
maxstd <span class="op">=</span> <span class="bu">max</span>(std(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> <span class="fl">1e-9</span>
C1 <span class="op">=</span> diag([<span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span>])
C1[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd
C1[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd
fp <span class="op">=</span> dot(C1,fp)

<span class="co"># --to points--</span>
m <span class="op">=</span> mean(tp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)
maxstd <span class="op">=</span> <span class="bu">max</span>(std(tp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> <span class="fl">1e-9</span>
C2 <span class="op">=</span> diag([<span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span>])
C2[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd
C2[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd
tp <span class="op">=</span> dot(C2,tp)

<span class="co"># create matrix for linear method, 2 rows for each correspondence pair</span>
nbr_correspondences <span class="op">=</span> fp.shape[<span class="dv">1</span>]
A <span class="op">=</span> zeros((<span class="dv">2</span><span class="op">*</span>nbr_correspondences,<span class="dv">9</span>))
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_correspondences):
    A[<span class="dv">2</span><span class="op">*</span>i] <span class="op">=</span> [<span class="op">-</span>fp[<span class="dv">0</span>][i],<span class="op">-</span>fp[<span class="dv">1</span>][i],<span class="op">-</span><span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,
                tp[<span class="dv">0</span>][i]<span class="op">*</span>fp[<span class="dv">0</span>][i],tp[<span class="dv">0</span>][i]<span class="op">*</span>fp[<span class="dv">1</span>][i],tp[<span class="dv">0</span>][i]]
    A[<span class="dv">2</span><span class="op">*</span>i<span class="dv">+1</span>] <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="op">-</span>fp[<span class="dv">0</span>][i],<span class="op">-</span>fp[<span class="dv">1</span>][i],<span class="op">-</span><span class="dv">1</span>,
                tp[<span class="dv">1</span>][i]<span class="op">*</span>fp[<span class="dv">0</span>][i],tp[<span class="dv">1</span>][i]<span class="op">*</span>fp[<span class="dv">1</span>][i],tp[<span class="dv">1</span>][i]]

U,S,V <span class="op">=</span> linalg.svd(A)
H <span class="op">=</span> V[<span class="dv">8</span>].reshape((<span class="dv">3</span>,<span class="dv">3</span>))

<span class="co"># decondition</span>
H <span class="op">=</span> dot(linalg.inv(C2),dot(H,C1))

<span class="co"># normalize and return</span>
<span class="cf">return</span> H <span class="op">/</span> H[<span class="dv">2</span>,<span class="dv">2</span>]</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Affine Transformations<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> Haffine_from_points(fp,tp):
    <span class="co">&quot;&quot;&quot; Find H, affine transformation, such that</span>
<span class="co">        tp is affine transf of fp. &quot;&quot;&quot;</span>

    <span class="cf">if</span> fp.shape <span class="op">!=</span> tp.shape:
        <span class="cf">raise</span> <span class="pp">RuntimeError</span>(<span class="st">&#39;number of points do not match&#39;</span>)

    <span class="co"># condition points</span>
    <span class="co"># --from points--</span>
    m <span class="op">=</span> mean(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)
    maxstd <span class="op">=</span> <span class="bu">max</span>(std(fp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)) <span class="op">+</span> <span class="fl">1e-9</span>
    C1 <span class="op">=</span> diag([<span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span><span class="op">/</span>maxstd, <span class="dv">1</span>])
    C1[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd
    C1[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd
    fp_cond <span class="op">=</span> dot(C1,fp)

    <span class="co"># --to points--</span>
    m <span class="op">=</span> mean(tp[:<span class="dv">2</span>], axis<span class="op">=</span><span class="dv">1</span>)
    C2 <span class="op">=</span> C1.copy() <span class="co">#must use same scaling for both point sets</span>
    C2[<span class="dv">0</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">0</span>]<span class="op">/</span>maxstd
    C2[<span class="dv">1</span>][<span class="dv">2</span>] <span class="op">=</span> <span class="op">-</span>m[<span class="dv">1</span>]<span class="op">/</span>maxstd
    tp_cond <span class="op">=</span> dot(C2,tp)

    <span class="co"># conditioned points have mean zero, so translation is zero</span>
    A <span class="op">=</span> concatenate((fp_cond[:<span class="dv">2</span>],tp_cond[:<span class="dv">2</span>]), axis<span class="op">=</span><span class="dv">0</span>)
    U,S,V <span class="op">=</span> linalg.svd(A.T)

    <span class="co"># create B and C matrices as Hartley-Zisserman (2:nd ed) p 130.</span>
    tmp <span class="op">=</span> V[:<span class="dv">2</span>].T
    B <span class="op">=</span> tmp[:<span class="dv">2</span>]
    C <span class="op">=</span> tmp[<span class="dv">2</span>:<span class="dv">4</span>]

    tmp2 <span class="op">=</span> concatenate((dot(C,linalg.pinv(B)),zeros((<span class="dv">2</span>,<span class="dv">1</span>))), axis<span class="op">=</span><span class="dv">1</span>)
    H <span class="op">=</span> vstack((tmp2,[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]))

    <span class="co"># decondition</span>
    H <span class="op">=</span> dot(linalg.inv(C2),dot(H,C1))

    <span class="cf">return</span> H <span class="op">/</span> H[<span class="dv">2</span>,<span class="dv">2</span>]</code></pre></div></li>
<li><p>Warping images</p>
<ol style="list-style-type: decimal">
<li>Image in Image<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy <span class="im">import</span> ndimage
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
H <span class="op">=</span> array([[<span class="fl">1.4</span>,<span class="fl">0.05</span>,<span class="op">-</span><span class="dv">100</span>],[<span class="fl">0.05</span>,<span class="fl">1.5</span>,<span class="op">-</span><span class="dv">100</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]])
im2 <span class="op">=</span> ndimage.affine_transform(im,H[:<span class="dv">2</span>,:<span class="dv">2</span>],(H[<span class="dv">0</span>,<span class="dv">2</span>],H[<span class="dv">1</span>,<span class="dv">2</span>]))

figure()
gray()
subplot(<span class="dv">121</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)
subplot(<span class="dv">122</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im2)
show()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.geometry <span class="im">import</span> warp, homography
<span class="im">from</span> PIL <span class="im">import</span>  Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy <span class="im">import</span> ndimage

<span class="co"># example of affine warp of im1 onto im2</span>

im1 <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/beatles.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
im2 <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/billboard_for_rent.jpg&#39;</span>).convert(<span class="st">&#39;L&#39;</span>))
<span class="co"># set to points</span>
tp <span class="op">=</span> array([[<span class="dv">120</span>,<span class="dv">260</span>,<span class="dv">260</span>,<span class="dv">120</span>],[<span class="dv">16</span>,<span class="dv">16</span>,<span class="dv">305</span>,<span class="dv">305</span>],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]])
<span class="co">#tp = array([[675,826,826,677],[55,52,281,277],[1,1,1,1]])</span>
im3 <span class="op">=</span> warp.image_in_image(im1,im2,tp)
figure()
gray()
subplot(<span class="dv">141</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im1)
subplot(<span class="dv">142</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im2)
subplot(<span class="dv">143</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im3)

<span class="co"># set from points to corners of im1</span>
m,n <span class="op">=</span> im1.shape[:<span class="dv">2</span>]
fp <span class="op">=</span> array([[<span class="dv">0</span>,m,m,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,n,n],[<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>]])
<span class="co"># first triangle</span>
tp2 <span class="op">=</span> tp[:,:<span class="dv">3</span>]
fp2 <span class="op">=</span> fp[:,:<span class="dv">3</span>]
<span class="co"># compute H</span>
H <span class="op">=</span> homography.Haffine_from_points(tp2,fp2)
im1_t <span class="op">=</span> ndimage.affine_transform(im1,H[:<span class="dv">2</span>,:<span class="dv">2</span>],
(H[<span class="dv">0</span>,<span class="dv">2</span>],H[<span class="dv">1</span>,<span class="dv">2</span>]),im2.shape[:<span class="dv">2</span>])
<span class="co"># alpha for triangle</span>
alpha <span class="op">=</span> warp.alpha_for_triangle(tp2,im2.shape[<span class="dv">0</span>],im2.shape[<span class="dv">1</span>])
im3 <span class="op">=</span> (<span class="dv">1</span><span class="op">-</span>alpha)<span class="op">*</span>im2 <span class="op">+</span> alpha<span class="op">*</span>im1_t
<span class="co"># second triangle</span>
tp2 <span class="op">=</span> tp[:,[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>]]
fp2 <span class="op">=</span> fp[:,[<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">3</span>]]
<span class="co"># compute H</span>
H <span class="op">=</span> homography.Haffine_from_points(tp2,fp2)
im1_t <span class="op">=</span> ndimage.affine_transform(im1,H[:<span class="dv">2</span>,:<span class="dv">2</span>],
(H[<span class="dv">0</span>,<span class="dv">2</span>],H[<span class="dv">1</span>,<span class="dv">2</span>]),im2.shape[:<span class="dv">2</span>])
<span class="co"># alpha for triangle</span>
alpha <span class="op">=</span> warp.alpha_for_triangle(tp2,im2.shape[<span class="dv">0</span>],im2.shape[<span class="dv">1</span>])
im4 <span class="op">=</span> (<span class="dv">1</span><span class="op">-</span>alpha)<span class="op">*</span>im3 <span class="op">+</span> alpha<span class="op">*</span>im1_t
subplot(<span class="dv">144</span>)
imshow(im4)
axis(<span class="st">&#39;off&#39;</span>)
show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Piecewise AffineWarping<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> matplotlib.delaunay <span class="im">as</span> md
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy <span class="im">import</span> <span class="op">*</span>

x,y <span class="op">=</span> array(random.standard_normal((<span class="dv">2</span>,<span class="dv">100</span>)))
centers,edges,tri,neighbors <span class="op">=</span> md.delaunay(x,y)
figure()
gray()
subplot(<span class="dv">121</span>)
axis(<span class="st">&#39;off&#39;</span>)
plot(x,y,<span class="st">&#39;*&#39;</span>)
<span class="cf">for</span> t <span class="op">in</span> tri:
   t_ext <span class="op">=</span> [t[<span class="dv">0</span>], t[<span class="dv">1</span>], t[<span class="dv">2</span>], t[<span class="dv">0</span>]] <span class="co"># add first point to end</span>
   subplot(<span class="dv">122</span>)
   plot(x[t_ext],y[t_ext],<span class="st">&#39;r&#39;</span>)
plot(x,y,<span class="st">&#39;*&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
show()</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Registering images<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> PCV.geometry <span class="im">import</span> warp

<span class="co">&quot;&quot;&quot;</span>
<span class="co">This is the piecewise affine warp example from Section 3.2, Figure 3-5.</span>
<span class="co">&quot;&quot;&quot;</span>

<span class="co"># open image to warp</span>
fromim <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/sunset_tree.jpg&#39;</span>))
x, y <span class="op">=</span> meshgrid(<span class="bu">range</span>(<span class="dv">5</span>), <span class="bu">range</span>(<span class="dv">6</span>))

x <span class="op">=</span> (fromim.shape[<span class="dv">1</span>]<span class="op">/</span><span class="dv">4</span>) <span class="op">*</span> x.flatten()
y <span class="op">=</span> (fromim.shape[<span class="dv">0</span>]<span class="op">/</span><span class="dv">5</span>) <span class="op">*</span> y.flatten()

<span class="co"># triangulate</span>
tri <span class="op">=</span> warp.triangulate_points(x, y)

<span class="co"># open image and destination points</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/turningtorso1.jpg&#39;</span>))

figure()
subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)

tp <span class="op">=</span> loadtxt(<span class="st">&#39;../data/turningtorso1_points.txt&#39;</span>, <span class="st">&#39;int&#39;</span>)  <span class="co"># destination points</span>

<span class="co"># convert points to hom. coordinates (make sure they are of type int)</span>
fp <span class="op">=</span> array(vstack((y, x, ones((<span class="dv">1</span>, <span class="bu">len</span>(x))))), <span class="st">&#39;int&#39;</span>)
tp <span class="op">=</span> array(vstack((tp[:, <span class="dv">1</span>], tp[:, <span class="dv">0</span>], ones((<span class="dv">1</span>, <span class="bu">len</span>(tp))))), <span class="st">&#39;int&#39;</span>)

<span class="co"># warp triangles</span>
im <span class="op">=</span> warp.pw_affine(fromim, im, fp, tp, tri)

<span class="co"># plot</span>
subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)
subplot(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">3</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)
warp.plot_mesh(tp[<span class="dv">1</span>], tp[<span class="dv">0</span>], tri)

show()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools <span class="im">import</span> imregistration

<span class="co">&quot;&quot;&quot;</span>
<span class="co">This is the face image registration example from Figure 3-6.</span>
<span class="co">Make sure to create a folder &#39;aligned&#39; under the jkfaces folder.</span>
<span class="co">&quot;&quot;&quot;</span>

<span class="co"># load the location of control points</span>
xml_filename <span class="op">=</span> <span class="st">&#39;../data/jkfaces.xml&#39;</span>
points <span class="op">=</span> imregistration.read_points_from_xml(xml_filename)

<span class="co"># register</span>
imregistration.rigid_alignment(points,<span class="st">&#39;../data/jkfaces/&#39;</span>)</code></pre></div></li>
<li>Creating panoramas<br/>
<ol style="list-style-type: decimal">
<li>RANSAC<br/> RANSAC, short for “RANdomSAmple Consensus,” is an iterative method to fit models to data that can contain outliers.<br/></li>
</ol></li>
</ol>
<h2 id="camera-models-and-augmented-reality">Camera models and augmented reality</h2>
<ol style="list-style-type: decimal">
<li>The pin-hole camera model<br/>
<ol style="list-style-type: decimal">
<li><p>Camera matrix<br/> A camera matrix can be composed as <span class="math inline">\(P=K[R|t]\)</span>, where <span class="math inline">\(R\)</span> is a rotation matrix describing the orientation of the camera, <span class="math inline">\(t\)</span> is a 3D translation vectors describing of the camera center, and the intrinsic calibration matrix <span class="math inline">\(K\)</span> describing the projection properties of the camera.<br/></p></li>
<li><p>Projecting 3D points<br/></p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy <span class="im">import</span> linalg
<span class="kw">class</span> Camera(<span class="bu">object</span>):
    <span class="co">&quot;&quot;&quot; Class for representing pin-hole cameras. &quot;&quot;&quot;</span>
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>,P):
        <span class="co">&quot;&quot;&quot; Initialize P = K[R|t] camera model. &quot;&quot;&quot;</span>
        <span class="va">self</span>.P <span class="op">=</span> P
        <span class="va">self</span>.K <span class="op">=</span> <span class="va">None</span> <span class="co"># calibration matrix</span>
        <span class="va">self</span>.R <span class="op">=</span> <span class="va">None</span> <span class="co"># rotation</span>
        <span class="va">self</span>.t <span class="op">=</span> <span class="va">None</span> <span class="co"># translation</span>
        <span class="va">self</span>.c <span class="op">=</span> <span class="va">None</span> <span class="co"># camera center</span>
    <span class="kw">def</span> project(<span class="va">self</span>,X):
        <span class="co">&quot;&quot;&quot; Project points in X (4*n array) and normalize coordinates. &quot;&quot;&quot;</span>
        x <span class="op">=</span> dot(<span class="va">self</span>.P,X)
        <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">3</span>):
            x[i] <span class="op">/=</span> x[<span class="dv">2</span>]
        <span class="cf">return</span> x</code></pre></div></li>
<li><p>Camera calibration<br/> Calibrating a camera means determining the internal camera parameters, in our case the matrixK. It is possible to extend this camera model to include radial distortion and other artifacts if your application needs precise measurements.<br/></p></li>
<li><p>Pose estimation from planes and markers</p></li>
<li><p>Augmented reality</p></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="multiple-view-geometry">Multiple view geometry</h2>
<ol style="list-style-type: decimal">
<li><p>Epipolar geometry</p></li>
<li><p>Computing with cameras and 3d structure</p></li>
<li><p>Multiple view reconstruction</p></li>
<li><p>Stereo images</p></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="clustering-images">Clustering images</h2>
<ol style="list-style-type: decimal">
<li>K-Means clustering<br/> K-means is a very simple clustering algorithm that tries to partition the input data in k clusters. K-means works by iteratively refining an initial estimate of calss controids as follows:<br/>
<ol style="list-style-type: decimal">
<li>Intialize centroids, <span class="math inline">\(\mu_i,i=1,...,k\)</span>, randomly or with some guess;<br/></li>
<li>Assign each data point to the class <span class="math inline">\(c_i\)</span> of its nearest centroid;<br/></li>
<li>Update the centroids as the average of all data points assigned to that class;<br/></li>
<li><p>Repeat 2 and 3 until convergence.<br/> <span class="math inline">\(K\)</span>-means tries to minimize the total within-class variance <span class="math inline">\(V=\sum_Pi=1{^k \sum_{x_j\in c_i}(x_j-\mu_i)^2}\)</span><br/></p></li>
<li><p>Clustering images<br/></p></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;</span>
<span class="co">Function:  figure 6.1</span>
<span class="co">    An example of k-means clustering of 2D points</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy.cluster.vq <span class="im">import</span> <span class="op">*</span>

class1 <span class="op">=</span> <span class="fl">1.5</span> <span class="op">*</span> randn(<span class="dv">100</span>, <span class="dv">2</span>)
class2 <span class="op">=</span> randn(<span class="dv">100</span>, <span class="dv">2</span>) <span class="op">+</span> array([<span class="dv">5</span>, <span class="dv">5</span>])
features <span class="op">=</span> vstack((class1, class2))
centroids, variance <span class="op">=</span> kmeans(features, <span class="dv">2</span>)
code, distance <span class="op">=</span> vq(features, centroids)
figure()
ndx <span class="op">=</span> where(code <span class="op">==</span> <span class="dv">0</span>)[<span class="dv">0</span>]
plot(features[ndx, <span class="dv">0</span>], features[ndx, <span class="dv">1</span>], <span class="st">&#39;*&#39;</span>)
ndx <span class="op">=</span> where(code <span class="op">==</span> <span class="dv">1</span>)[<span class="dv">0</span>]
plot(features[ndx, <span class="dv">0</span>], features[ndx, <span class="dv">1</span>], <span class="st">&#39;r.&#39;</span>)
plot(centroids[:, <span class="dv">0</span>], centroids[:, <span class="dv">1</span>], <span class="st">&#39;go&#39;</span>)

title(<span class="st">&#39;2-D data clustering&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Visualizing the images on principal components<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools <span class="im">import</span> imtools, pca
<span class="im">from</span> PIL <span class="im">import</span> Image, ImageDraw
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

imlist <span class="op">=</span> imtools.get_imlist(<span class="st">&#39;../data/selectedfontimages/a_selected_thumbs&#39;</span>)
imnbr <span class="op">=</span> <span class="bu">len</span>(imlist)

<span class="co"># Load images, run PCA.</span>
immatrix <span class="op">=</span> array([array(Image.<span class="bu">open</span>(im)).flatten() <span class="cf">for</span> im <span class="op">in</span> imlist], <span class="st">&#39;f&#39;</span>)
V, S, immean <span class="op">=</span> pca.pca(immatrix)

<span class="co"># Project on 2 PCs.</span>
projected <span class="op">=</span> array([dot(V[[<span class="dv">0</span>, <span class="dv">1</span>]], immatrix[i] <span class="op">-</span> immean) <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(imnbr)])  <span class="co"># P131 Fig6-3左图</span>
<span class="co">#projected = array([dot(V[[1, 2]], immatrix[i] - immean) for i in range(imnbr)])  # P131 Fig6-3右图</span>

<span class="co"># height and width</span>
h, w <span class="op">=</span> <span class="dv">1200</span>, <span class="dv">1200</span>

<span class="co"># create a new image with a white background</span>
img <span class="op">=</span> Image.new(<span class="st">&#39;RGB&#39;</span>, (w, h), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>))
draw <span class="op">=</span> ImageDraw.Draw(img)

<span class="co"># draw axis</span>
draw.line((<span class="dv">0</span>, h<span class="op">/</span><span class="dv">2</span>, w, h<span class="op">/</span><span class="dv">2</span>), fill<span class="op">=</span>(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>))
draw.line((w<span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>, w<span class="op">/</span><span class="dv">2</span>, h), fill<span class="op">=</span>(<span class="dv">255</span>, <span class="dv">0</span>, <span class="dv">0</span>))

<span class="co"># scale coordinates to fit</span>
scale <span class="op">=</span> <span class="bu">abs</span>(projected).<span class="bu">max</span>(<span class="dv">0</span>)
scaled <span class="op">=</span> floor(array([(p<span class="op">/</span>scale) <span class="op">*</span> (w<span class="op">/</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">20</span>, h<span class="op">/</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">20</span>) <span class="op">+</span> (w<span class="op">/</span><span class="dv">2</span>, h<span class="op">/</span><span class="dv">2</span>)
                     <span class="cf">for</span> p <span class="op">in</span> projected])).astype(<span class="bu">int</span>)

<span class="co"># paste thumbnail of each image</span>
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(imnbr):
 nodeim <span class="op">=</span> Image.<span class="bu">open</span>(imlist[i])
 nodeim.thumbnail((<span class="dv">25</span>, <span class="dv">25</span>))
 ns <span class="op">=</span> nodeim.size
 box <span class="op">=</span> (scaled[i][<span class="dv">0</span>] <span class="op">-</span> ns[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span>, scaled[i][<span class="dv">1</span>] <span class="op">-</span> ns[<span class="dv">1</span>] <span class="op">//</span> <span class="dv">2</span>,
        scaled[i][<span class="dv">0</span>] <span class="op">+</span> ns[<span class="dv">0</span>] <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>, scaled[i][<span class="dv">1</span>] <span class="op">+</span> ns[<span class="dv">1</span>] <span class="op">//</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span>)
 img.paste(nodeim, box)

img.show()
img.save(<span class="st">&#39;../images/ch06/pca_font.png&#39;</span>)</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Clustering pixels<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">&quot;&quot;&quot;</span>
<span class="co">    Clustering of pixels based on their color value using k-means.</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="im">from</span> scipy.cluster.vq <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> scipy.misc <span class="im">import</span> imresize
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">import</span> Image

steps <span class="op">=</span> <span class="dv">100</span>  <span class="co"># image is divided in steps*steps region</span>
infile <span class="op">=</span> <span class="st">&#39;../data/empire.jpg&#39;</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(infile))
dx <span class="op">=</span> im.shape[<span class="dv">0</span>] <span class="op">/</span> steps
dy <span class="op">=</span> im.shape[<span class="dv">1</span>] <span class="op">/</span> steps
<span class="co"># compute color features for each region</span>
features <span class="op">=</span> []
<span class="cf">for</span> x <span class="op">in</span> <span class="bu">range</span>(steps):
    <span class="cf">for</span> y <span class="op">in</span> <span class="bu">range</span>(steps):
        R <span class="op">=</span> mean(im[x <span class="op">*</span> dx:(x <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dx, y <span class="op">*</span> dy:(y <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dy, <span class="dv">0</span>])
        G <span class="op">=</span> mean(im[x <span class="op">*</span> dx:(x <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dx, y <span class="op">*</span> dy:(y <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dy, <span class="dv">1</span>])
        B <span class="op">=</span> mean(im[x <span class="op">*</span> dx:(x <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dx, y <span class="op">*</span> dy:(y <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> dy, <span class="dv">2</span>])
        features.append([R, G, B])
features <span class="op">=</span> array(features, <span class="st">&#39;f&#39;</span>)     <span class="co"># make into array</span>
<span class="co"># cluster</span>
centroids, variance <span class="op">=</span> kmeans(features, <span class="dv">3</span>)
code, distance <span class="op">=</span> vq(features, centroids)
<span class="co"># create image with cluster labels</span>
codeim <span class="op">=</span> code.reshape(steps, steps)
codeim <span class="op">=</span> imresize(codeim, im.shape[:<span class="dv">2</span>], <span class="st">&#39;nearest&#39;</span>)

figure()
ax1 <span class="op">=</span> subplot(<span class="dv">121</span>)
title(<span class="st">&#39;Raw image&#39;</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)

ax2 <span class="op">=</span> subplot(<span class="dv">122</span>)
title(<span class="st">&#39;Clustered images&#39;</span>)
<span class="co">#ax2.set_title(&#39;Image after clustering&#39;)</span>
axis(<span class="st">&#39;off&#39;</span>)
imshow(codeim)

show()</code></pre></div></li>
<li><p>Hierarchical clustering<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> os
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> PCV.clustering <span class="im">import</span> hcluster
<span class="co"># create a list of images</span>
<span class="im">from</span> matplotlib.pyplot <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>

path <span class="op">=</span> <span class="st">&#39;../data/sunsets/flickr-sunsets-small/&#39;</span>
imlist <span class="op">=</span> [os.path.join(path, f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.jpg&#39;</span>)]
<span class="co"># extract feature vector (8 bins per color channel)</span>
features <span class="op">=</span> zeros([<span class="bu">len</span>(imlist), <span class="dv">512</span>])
<span class="cf">for</span> i, f <span class="op">in</span> <span class="bu">enumerate</span>(imlist):
    im <span class="op">=</span> array(Image.<span class="bu">open</span>(f))
    <span class="co"># multi-dimensional histogram</span>
    h, edges <span class="op">=</span> histogramdd(im.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">3</span>), <span class="dv">8</span>, normed<span class="op">=</span><span class="va">True</span>, <span class="bu">range</span><span class="op">=</span>[(<span class="dv">0</span>, <span class="dv">255</span>), (<span class="dv">0</span>, <span class="dv">255</span>), (<span class="dv">0</span>, <span class="dv">255</span>)])
    features[i] <span class="op">=</span> h.flatten()
tree <span class="op">=</span> hcluster.hcluster(features)

<span class="co"># visualize clusters with some (arbitrary) threshold</span>
clusters <span class="op">=</span> tree.extract_clusters(<span class="fl">0.23</span> <span class="op">*</span> tree.distance)
<span class="co"># plot images for clusters with more than 3 elements</span>
<span class="cf">for</span> c <span class="op">in</span> clusters:
    elements <span class="op">=</span> c.get_cluster_elements()
    nbr_elements <span class="op">=</span> <span class="bu">len</span>(elements)
    <span class="cf">if</span> nbr_elements <span class="op">&gt;</span> <span class="dv">3</span>:
        figure()
        <span class="cf">for</span> p <span class="op">in</span> <span class="bu">range</span>(minimum(nbr_elements,<span class="dv">20</span>)):
            subplot(<span class="dv">4</span>, <span class="dv">5</span>, p <span class="op">+</span> <span class="dv">1</span>)
            im <span class="op">=</span> array(Image.<span class="bu">open</span>(imlist[elements[p]]))
            imshow(im)
            axis(<span class="st">&#39;off&#39;</span>)
show()</code></pre></div></li>
<li><p>Spectral clustering<br/></p></li>
</ol>
<h2 id="searching-images">Searching images</h2>
<ol style="list-style-type: decimal">
<li><p>Content-based image retrieval</p></li>
<li>Visual words<br/>
<ol style="list-style-type: decimal">
<li>Creating a vocabulary<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> PCV.imagesearch <span class="im">import</span> vocabulary
<span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift

<span class="co">#获取图像列表</span>
imlist <span class="op">=</span> get_imlist(<span class="st">&#39;../data/first1000/&#39;</span>)
nbr_images <span class="op">=</span> <span class="bu">len</span>(imlist)
<span class="co">#获取特征列表</span>
featlist <span class="op">=</span> [imlist[i][:<span class="op">-</span><span class="dv">3</span>]<span class="op">+</span><span class="st">&#39;sift&#39;</span> <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_images)]

<span class="co">#提取文件夹下图像的sift特征</span>
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_images):
    sift.process_image(imlist[i], featlist[i])

<span class="co">#生成词汇</span>
voc <span class="op">=</span> vocabulary.Vocabulary(<span class="st">&#39;ukbenchtest&#39;</span>)
voc.train(featlist, <span class="dv">1000</span>, <span class="dv">10</span>)
<span class="co">#保存词汇</span>
<span class="co"># saving vocabulary</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;../data/first1000/vocabulary.pkl&#39;</span>, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> f:
    pickle.dump(voc, f)
<span class="bu">print</span> <span class="st">&#39;vocabulary is:&#39;</span>, voc.name, voc.nbr_words</code></pre></div></li>
<li><p>Indexing images<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> PCV.imagesearch <span class="im">import</span> imagesearch
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift
<span class="im">from</span> sqlite3 <span class="im">import</span> dbapi2 <span class="im">as</span> sqlite
<span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist

<span class="co">#获取图像列表</span>
imlist <span class="op">=</span> get_imlist(<span class="st">&#39;./first500/&#39;</span>)
nbr_images <span class="op">=</span> <span class="bu">len</span>(imlist)
<span class="co">#获取特征列表</span>
featlist <span class="op">=</span> [imlist[i][:<span class="op">-</span><span class="dv">3</span>]<span class="op">+</span><span class="st">&#39;sift&#39;</span> <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_images)]

<span class="co"># load vocabulary</span>
<span class="co">#载入词汇</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;./first500/vocabulary.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    voc <span class="op">=</span> pickle.load(f)
<span class="co">#创建索引</span>
indx <span class="op">=</span> imagesearch.Indexer(<span class="st">&#39;testImaAdd.db&#39;</span>,voc)
indx.create_tables()
<span class="co"># go through all images, project features on vocabulary and insert</span>
<span class="co">#遍历所有的图像，并将它们的特征投影到词汇上</span>
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_images)[:<span class="dv">500</span>]:
    locs,descr <span class="op">=</span> sift.read_features_from_file(featlist[i])
    indx.add_to_index(imlist[i],descr)
<span class="co"># commit to database</span>
<span class="co">#提交到数据库</span>
indx.db_commit()

con <span class="op">=</span> sqlite.<span class="ex">connect</span>(<span class="st">&#39;testImaAdd.db&#39;</span>)
<span class="bu">print</span> con.execute(<span class="st">&#39;select count (filename) from imlist&#39;</span>).fetchone()
<span class="bu">print</span> con.execute(<span class="st">&#39;select * from imlist&#39;</span>).fetchone()</code></pre></div></li>
<li><p>Searching the database for images<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cherrypy
<span class="im">import</span> pickle
<span class="im">import</span> urllib
<span class="im">import</span> os
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="co">#from PCV.tools.imtools import get_imlist</span>
<span class="im">from</span> PCV.imagesearch <span class="im">import</span> imagesearch

<span class="co">&quot;&quot;&quot;</span>
<span class="co">This is the image search demo in Section 7.6.</span>
<span class="co">&quot;&quot;&quot;</span>


<span class="kw">class</span> SearchDemo:

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="co"># 载入图像列表</span>
        <span class="va">self</span>.path <span class="op">=</span> <span class="st">&#39;./first500/&#39;</span>
        <span class="co">#self.path = &#39;D:/python_web/isoutu/first500/&#39;</span>
        <span class="va">self</span>.imlist <span class="op">=</span> [os.path.join(<span class="va">self</span>.path,f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(<span class="va">self</span>.path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.jpg&#39;</span>)]
        <span class="co">#self.imlist = get_imlist(&#39;./first500/&#39;)</span>
        <span class="co">#self.imlist = get_imlist(&#39;E:/python/isoutu/first500/&#39;)</span>
        <span class="va">self</span>.nbr_images <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.imlist)
        <span class="va">self</span>.ndx <span class="op">=</span> <span class="bu">range</span>(<span class="va">self</span>.nbr_images)

        <span class="co"># 载入词汇</span>
        f <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;./first500/vocabulary.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>)
        <span class="va">self</span>.voc <span class="op">=</span> pickle.load(f)
        f.close()

        <span class="co"># 显示搜索返回的图像数</span>
        <span class="va">self</span>.maxres <span class="op">=</span> <span class="dv">49</span>

        <span class="co"># header and footer html</span>
        <span class="va">self</span>.header <span class="op">=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;!doctype html&gt;</span>
<span class="st">            &lt;head&gt;</span>
<span class="st">            &lt;title&gt;Image search&lt;/title&gt;</span>
<span class="st">            &lt;/head&gt;</span>
<span class="st">            &lt;body&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>
        <span class="va">self</span>.footer <span class="op">=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;/body&gt;</span>
<span class="st">            &lt;/html&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>

    <span class="kw">def</span> index(<span class="va">self</span>, query<span class="op">=</span><span class="va">None</span>):
        <span class="va">self</span>.src <span class="op">=</span> imagesearch.Searcher(<span class="st">&#39;testImaAdd.db&#39;</span>, <span class="va">self</span>.voc)

        html <span class="op">=</span> <span class="va">self</span>.header
        html <span class="op">+=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;br /&gt;</span>
<span class="st">            Click an image to search. &lt;a href=&#39;?query=&#39;&gt; Random selection &lt;/a&gt; of images.</span>
<span class="st">            &lt;br /&gt;&lt;br /&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>
        <span class="cf">if</span> query:
            <span class="co"># query the database and get top images</span>
            <span class="co">#查询数据库，并获取前面的图像</span>
            res <span class="op">=</span> <span class="va">self</span>.src.query(query)[:<span class="va">self</span>.maxres]
            <span class="cf">for</span> dist, ndx <span class="op">in</span> res:
                imname <span class="op">=</span> <span class="va">self</span>.src.get_filename(ndx)
                html <span class="op">+=</span> <span class="st">&quot;&lt;a href=&#39;?query=&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39;&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;img src=&#39;&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39; width=&#39;200&#39; /&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>
            <span class="co"># show random selection if no query</span>
            <span class="co"># 如果没有查询图像则随机显示一些图像</span>
        <span class="cf">else</span>:
            random.shuffle(<span class="va">self</span>.ndx)
            <span class="cf">for</span> i <span class="op">in</span> <span class="va">self</span>.ndx[:<span class="va">self</span>.maxres]:
                imname <span class="op">=</span> <span class="va">self</span>.imlist[i]
                html <span class="op">+=</span> <span class="st">&quot;&lt;a href=&#39;?query=&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39;&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;img src=&#39;&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39; width=&#39;200&#39; /&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>

        html <span class="op">+=</span> <span class="va">self</span>.footer
        <span class="cf">return</span> html

    index.exposed <span class="op">=</span> <span class="va">True</span>
conf_path <span class="op">=</span> os.path.dirname(os.path.abspath(<span class="va">__file__</span>))
conf_path <span class="op">=</span> os.path.join(conf_path, <span class="st">&quot;service.conf&quot;</span>)
cherrypy.config.update(conf_path)
cherrypy.quickstart(SearchDemo())

cherrypy.quickstart(SearchDemo(), <span class="st">&#39;/&#39;</span>, config<span class="op">=</span>os.path.join(os.path.dirname(<span class="va">__file__</span>), <span class="st">&#39;service.conf&#39;</span>))</code></pre></div></li>
<li><p>Ranking results using geometry<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift
<span class="im">from</span> PCV.imagesearch <span class="im">import</span> imagesearch
<span class="im">from</span> PCV.geometry <span class="im">import</span> homography
<span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist

<span class="co"># load image list and vocabulary</span>
<span class="co">#载入图像列表</span>
imlist <span class="op">=</span> get_imlist(<span class="st">&#39;./first500/&#39;</span>)
nbr_images <span class="op">=</span> <span class="bu">len</span>(imlist)
<span class="co">#载入特征列表</span>
featlist <span class="op">=</span> [imlist[i][:<span class="op">-</span><span class="dv">3</span>]<span class="op">+</span><span class="st">&#39;sift&#39;</span> <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(nbr_images)]

<span class="co">#载入词汇</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;./first500/vocabulary.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>) <span class="im">as</span> f:
    voc <span class="op">=</span> pickle.load(f)

src <span class="op">=</span> imagesearch.Searcher(<span class="st">&#39;testImaAdd.db&#39;</span>,voc)

<span class="co"># index of query image and number of results to return</span>
<span class="co">#查询图像索引和查询返回的图像数</span>
q_ind <span class="op">=</span> <span class="dv">0</span>
nbr_results <span class="op">=</span> <span class="dv">20</span>

<span class="co"># regular query</span>
<span class="co"># 常规查询(按欧式距离对结果排序)</span>
res_reg <span class="op">=</span> [w[<span class="dv">1</span>] <span class="cf">for</span> w <span class="op">in</span> src.query(imlist[q_ind])[:nbr_results]]
<span class="bu">print</span> <span class="st">&#39;top matches (regular):&#39;</span>, res_reg

<span class="co"># load image features for query image</span>
<span class="co">#载入查询图像特征</span>
q_locs,q_descr <span class="op">=</span> sift.read_features_from_file(featlist[q_ind])
fp <span class="op">=</span> homography.make_homog(q_locs[:,:<span class="dv">2</span>].T)

<span class="co"># RANSAC model for homography fitting</span>
<span class="co">#用单应性进行拟合建立RANSAC模型</span>
model <span class="op">=</span> homography.RansacModel()
rank <span class="op">=</span> {}

<span class="co"># load image features for result</span>
<span class="co">#载入候选图像的特征</span>
<span class="cf">for</span> ndx <span class="op">in</span> res_reg[<span class="dv">1</span>:]:
    locs,descr <span class="op">=</span> sift.read_features_from_file(featlist[ndx])  <span class="co"># because &#39;ndx&#39; is a rowid of the DB that starts at 1</span>
    <span class="co"># get matches</span>
    matches <span class="op">=</span> sift.match(q_descr,descr)
    ind <span class="op">=</span> matches.nonzero()[<span class="dv">0</span>]
    ind2 <span class="op">=</span> matches[ind]
    tp <span class="op">=</span> homography.make_homog(locs[:,:<span class="dv">2</span>].T)
    <span class="co"># compute homography, count inliers. if not enough matches return empty list</span>
    <span class="cf">try</span>:
        H,inliers <span class="op">=</span> homography.H_from_ransac(fp[:,ind],tp[:,ind2],model,match_theshold<span class="op">=</span><span class="dv">4</span>)
    <span class="cf">except</span>:
        inliers <span class="op">=</span> []
    <span class="co"># store inlier count</span>
    rank[ndx] <span class="op">=</span> <span class="bu">len</span>(inliers)

<span class="co"># sort dictionary to get the most inliers first</span>
sorted_rank <span class="op">=</span> <span class="bu">sorted</span>(rank.items(), key<span class="op">=</span><span class="kw">lambda</span> t: t[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)
res_geom <span class="op">=</span> [res_reg[<span class="dv">0</span>]]<span class="op">+</span>[s[<span class="dv">0</span>] <span class="cf">for</span> s <span class="op">in</span> sorted_rank]
<span class="bu">print</span> <span class="st">&#39;top matches (homography):&#39;</span>, res_geom

<span class="co"># 显示查询结果</span>
imagesearch.plot_results(src,res_reg[:<span class="dv">8</span>]) <span class="co">#常规查询</span>
imagesearch.plot_results(src,res_geom[:<span class="dv">8</span>]) <span class="co">#重排后的结果</span></code></pre></div></li>
<li><p>Building demos and web applications<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cherrypy
<span class="im">import</span> pickle
<span class="im">import</span> urllib
<span class="im">import</span> os
<span class="im">from</span> numpy <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.tools.imtools <span class="im">import</span> get_imlist
<span class="im">from</span> PCV.imagesearch <span class="im">import</span> imagesearch

<span class="co">&quot;&quot;&quot;</span>
<span class="co">This is the image search demo in Section 7.6.</span>
<span class="co">&quot;&quot;&quot;</span>
<span class="kw">class</span> SearchDemo:

    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):
        <span class="co"># 载入图像列表</span>
        <span class="va">self</span>.path <span class="op">=</span> <span class="st">&#39;./first500/&#39;</span>
        <span class="co">#self.path = &#39;D:/python_web/isoutu/first500/&#39;</span>
        <span class="va">self</span>.imlist <span class="op">=</span> [os.path.join(<span class="va">self</span>.path,f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(<span class="va">self</span>.path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.jpg&#39;</span>)]
        <span class="co">#self.imlist = get_imlist(&#39;./first500/&#39;)</span>
        <span class="co">#self.imlist = get_imlist(&#39;E:/python/isoutu/first500/&#39;)</span>
        <span class="va">self</span>.nbr_images <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.imlist)
        <span class="va">self</span>.ndx <span class="op">=</span> <span class="bu">range</span>(<span class="va">self</span>.nbr_images)

        <span class="co"># 载入词汇</span>
        f <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;./first500/vocabulary.pkl&#39;</span>, <span class="st">&#39;rb&#39;</span>)
        <span class="va">self</span>.voc <span class="op">=</span> pickle.load(f)
        f.close()

        <span class="co"># 显示搜索返回的图像数</span>
        <span class="va">self</span>.maxres <span class="op">=</span> <span class="dv">49</span>

        <span class="co"># header and footer html</span>
        <span class="va">self</span>.header <span class="op">=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;!doctype html&gt;</span>
<span class="st">            &lt;head&gt;</span>
<span class="st">            &lt;/head&gt;</span>
<span class="st">            &lt;title&gt;Image search&lt;/title&gt;</span>
<span class="st">            &lt;body&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>
        <span class="va">self</span>.footer <span class="op">=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;/body&gt;</span>
<span class="st">            &lt;/html&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>

    <span class="kw">def</span> index(<span class="va">self</span>, query<span class="op">=</span><span class="va">None</span>):
        <span class="va">self</span>.src <span class="op">=</span> imagesearch.Searcher(<span class="st">&#39;testImaAdd.db&#39;</span>, <span class="va">self</span>.voc)

        html <span class="op">=</span> <span class="va">self</span>.header
        html <span class="op">+=</span> <span class="st">&quot;&quot;&quot;</span>
<span class="st">            &lt;br /&gt;</span>
<span class="st">            Click an image to search. &lt;a href=&#39;?query=&#39;&gt; Random selection &lt;/a&gt; of images.</span>
<span class="st">            &lt;br /&gt;&lt;br /&gt;</span>
<span class="st">            &quot;&quot;&quot;</span>
        <span class="cf">if</span> query:
            <span class="co"># query the database and get top images</span>
            <span class="co">#查询数据库，并获取前面的图像</span>
            res <span class="op">=</span> <span class="va">self</span>.src.query(query)[:<span class="va">self</span>.maxres]
            <span class="cf">for</span> dist, ndx <span class="op">in</span> res:
                imname <span class="op">=</span> <span class="va">self</span>.src.get_filename(ndx)
                html <span class="op">+=</span> <span class="st">&quot;&lt;a href=&#39;?query=&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39;&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;img src=&#39;&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39; width=&#39;200&#39; /&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>
            <span class="co"># show random selection if no query</span>
            <span class="co"># 如果没有查询图像则随机显示一些图像</span>
        <span class="cf">else</span>:
            random.shuffle(<span class="va">self</span>.ndx)
            <span class="cf">for</span> i <span class="op">in</span> <span class="va">self</span>.ndx[:<span class="va">self</span>.maxres]:
                imname <span class="op">=</span> <span class="va">self</span>.imlist[i]
                html <span class="op">+=</span> <span class="st">&quot;&lt;a href=&#39;?query=&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39;&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;img src=&#39;&quot;</span><span class="op">+</span>imname<span class="op">+</span><span class="st">&quot;&#39; width=&#39;200&#39; /&gt;&quot;</span>
                html <span class="op">+=</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>

        html <span class="op">+=</span> <span class="va">self</span>.footer
        <span class="cf">return</span> html

    index.exposed <span class="op">=</span> <span class="va">True</span>

conf_path <span class="op">=</span> os.path.dirname(os.path.abspath(<span class="va">__file__</span>))
conf_path <span class="op">=</span> os.path.join(conf_path, <span class="st">&quot;service.conf&quot;</span>)
cherrypy.config.update(conf_path)
cherrypy.quickstart(SearchDemo())

cherrypy.quickstart(SearchDemo(), <span class="st">&#39;/&#39;</span>, config<span class="op">=</span>os.path.join(os.path.dirname(<span class="va">__file__</span>), <span class="st">&#39;service.conf&#39;</span>))</code></pre></div></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="classifying-image-content">Classifying image content</h2>
<ol style="list-style-type: decimal">
<li><p>K-nearest neighbors<br/></p>
<ol style="list-style-type: decimal">
<li>A simple 2D example<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> numpy.random <span class="im">import</span> randn
<span class="im">import</span> pickle
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

<span class="co"># create sample data of 2D points</span>
n <span class="op">=</span> <span class="dv">200</span>
<span class="co"># two normal distributions</span>
class_1 <span class="op">=</span> <span class="fl">0.6</span> <span class="op">*</span> randn(n,<span class="dv">2</span>)
class_2 <span class="op">=</span> <span class="fl">1.2</span> <span class="op">*</span> randn(n,<span class="dv">2</span>) <span class="op">+</span> array([<span class="dv">5</span>,<span class="dv">1</span>])
labels <span class="op">=</span> hstack((ones(n),<span class="op">-</span>ones(n)))
<span class="co"># save with Pickle</span>
<span class="co">#with open(&#39;points_normal.pkl&#39;, &#39;w&#39;) as f:</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;points_normal_test.pkl&#39;</span>, <span class="st">&#39;w&#39;</span>) <span class="im">as</span> f:
    pickle.dump(class_1,f)
    pickle.dump(class_2,f)
    pickle.dump(labels,f)
<span class="co"># normal distribution and ring around it</span>
class_1 <span class="op">=</span> <span class="fl">0.6</span> <span class="op">*</span> randn(n,<span class="dv">2</span>)
r <span class="op">=</span> <span class="fl">0.8</span> <span class="op">*</span> randn(n,<span class="dv">1</span>) <span class="op">+</span> <span class="dv">5</span>
angle <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>pi <span class="op">*</span> randn(n,<span class="dv">1</span>)
class_2 <span class="op">=</span> hstack((r<span class="op">*</span>cos(angle),r<span class="op">*</span>sin(angle)))
labels <span class="op">=</span> hstack((ones(n),<span class="op">-</span>ones(n)))
<span class="co"># save with Pickle</span>
<span class="co">#with open(&#39;points_ring.pkl&#39;, &#39;w&#39;) as f:</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="st">&#39;points_ring_test.pkl&#39;</span>, <span class="st">&#39;w&#39;</span>) <span class="im">as</span> f:
    pickle.dump(class_1,f)
    pickle.dump(class_2,f)
    pickle.dump(labels,f)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pickle
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.classifiers <span class="im">import</span> knn
<span class="im">from</span> PCV.tools <span class="im">import</span> imtools

pklist<span class="op">=</span>[<span class="st">&#39;points_normal.pkl&#39;</span>,<span class="st">&#39;points_ring.pkl&#39;</span>]

figure()

<span class="co"># load 2D points using Pickle</span>
<span class="cf">for</span> i, pklfile <span class="op">in</span> <span class="bu">enumerate</span>(pklist):
    <span class="cf">with</span> <span class="bu">open</span>(pklfile, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> f:
        class_1 <span class="op">=</span> pickle.load(f)
        class_2 <span class="op">=</span> pickle.load(f)
        labels <span class="op">=</span> pickle.load(f)
    <span class="co"># load test data using Pickle</span>
    <span class="cf">with</span> <span class="bu">open</span>(pklfile[:<span class="op">-</span><span class="dv">4</span>]<span class="op">+</span><span class="st">&#39;_test.pkl&#39;</span>, <span class="st">&#39;r&#39;</span>) <span class="im">as</span> f:
        class_1 <span class="op">=</span> pickle.load(f)
        class_2 <span class="op">=</span> pickle.load(f)
        labels <span class="op">=</span> pickle.load(f)

    model <span class="op">=</span> knn.KnnClassifier(labels,vstack((class_1,class_2)))
    <span class="co"># test on the first point</span>
    <span class="bu">print</span> model.classify(class_1[<span class="dv">0</span>])

    <span class="co">#define function for plotting</span>
    <span class="kw">def</span> classify(x,y,model<span class="op">=</span>model):
        <span class="cf">return</span> array([model.classify([xx,yy]) <span class="cf">for</span> (xx,yy) <span class="op">in</span> <span class="bu">zip</span>(x,y)])

    <span class="co"># lot the classification boundary</span>
    subplot(<span class="dv">1</span>,<span class="dv">2</span>,i<span class="dv">+1</span>)
    imtools.plot_2D_boundary([<span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>,<span class="op">-</span><span class="dv">6</span>,<span class="dv">6</span>],[class_1,class_2],classify,[<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>])
    titlename<span class="op">=</span>pklfile[:<span class="op">-</span><span class="dv">4</span>]
    title(titlename)
show()</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Dense SIFT as Image Feature<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift, dsift
<span class="im">from</span> pylab <span class="im">import</span>  <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image

dsift.process_image_dsift(<span class="st">&#39;../data/empire.jpg&#39;</span>,<span class="st">&#39;empire.dsift&#39;</span>,<span class="dv">90</span>,<span class="dv">40</span>,<span class="va">True</span>)
l,d <span class="op">=</span> sift.read_features_from_file(<span class="st">&#39;empire.dsift&#39;</span>)
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/empire.jpg&#39;</span>))
sift.plot_features(im,l,<span class="va">True</span>)
title(<span class="st">&#39;dense SIFT&#39;</span>)
show()</code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Clasifying images - hand gesture recognition<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.localdescriptors <span class="im">import</span> dsift
<span class="im">import</span> os
<span class="im">from</span> PCV.localdescriptors <span class="im">import</span> sift
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PCV.classifiers <span class="im">import</span> knn

<span class="kw">def</span> get_imagelist(path):
    <span class="co">&quot;&quot;&quot;    Returns a list of filenames for</span>
<span class="co">        all jpg images in a directory. &quot;&quot;&quot;</span>

    <span class="cf">return</span> [os.path.join(path,f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.ppm&#39;</span>)]

<span class="kw">def</span> read_gesture_features_labels(path):
    <span class="co"># create list of all files ending in .dsift</span>
    featlist <span class="op">=</span> [os.path.join(path,f) <span class="cf">for</span> f <span class="op">in</span> os.listdir(path) <span class="cf">if</span> f.endswith(<span class="st">&#39;.dsift&#39;</span>)]
    <span class="co"># read the features</span>
    features <span class="op">=</span> []
    <span class="cf">for</span> featfile <span class="op">in</span> featlist:
        l,d <span class="op">=</span> sift.read_features_from_file(featfile)
        features.append(d.flatten())
    features <span class="op">=</span> array(features)
    <span class="co"># create labels</span>
    labels <span class="op">=</span> [featfile.split(<span class="st">&#39;/&#39;</span>)[<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="cf">for</span> featfile <span class="op">in</span> featlist]
    <span class="cf">return</span> features,array(labels)

<span class="kw">def</span> print_confusion(res,labels,classnames):
    n <span class="op">=</span> <span class="bu">len</span>(classnames)
    <span class="co"># confusion matrix</span>
    class_ind <span class="op">=</span> <span class="bu">dict</span>([(classnames[i],i) <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(n)])
    confuse <span class="op">=</span> zeros((n,n))
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(test_labels)):
        confuse[class_ind[res[i]],class_ind[test_labels[i]]] <span class="op">+=</span> <span class="dv">1</span>
    <span class="bu">print</span> <span class="st">&#39;Confusion matrix for&#39;</span>
    <span class="bu">print</span> classnames
    <span class="bu">print</span> confuse

filelist_train <span class="op">=</span> get_imagelist(<span class="st">&#39;../data/gesture/train&#39;</span>)
filelist_test <span class="op">=</span> get_imagelist(<span class="st">&#39;../data/gesture/test&#39;</span>)
imlist<span class="op">=</span>filelist_train<span class="op">+</span>filelist_test

<span class="co"># process images at fixed size (50,50)</span>
<span class="cf">for</span> filename <span class="op">in</span> imlist:
    featfile <span class="op">=</span> filename[:<span class="op">-</span><span class="dv">3</span>]<span class="op">+</span><span class="st">&#39;dsift&#39;</span>
    dsift.process_image_dsift(filename,featfile,<span class="dv">10</span>,<span class="dv">5</span>,resize<span class="op">=</span>(<span class="dv">50</span>,<span class="dv">50</span>))

features,labels <span class="op">=</span> read_gesture_features_labels(<span class="st">&#39;../data/gesture/train/&#39;</span>)
test_features,test_labels <span class="op">=</span> read_gesture_features_labels(<span class="st">&#39;../data/gesture/test/&#39;</span>)
classnames <span class="op">=</span> unique(labels)

<span class="co"># test kNN</span>
k <span class="op">=</span> <span class="dv">1</span>
knn_classifier <span class="op">=</span> knn.KnnClassifier(labels,features)
res <span class="op">=</span> array([knn_classifier.classify(test_features[i],k) <span class="cf">for</span> i <span class="op">in</span>
<span class="bu">range</span>(<span class="bu">len</span>(test_labels))])
<span class="co"># accuracy</span>
acc <span class="op">=</span> <span class="bu">sum</span>(<span class="fl">1.0</span><span class="op">*</span>(res<span class="op">==</span>test_labels)) <span class="op">/</span> <span class="bu">len</span>(test_labels)
<span class="bu">print</span> <span class="st">&#39;Accuracy:&#39;</span>, acc

print_confusion(res,test_labels,classnames)</code></pre></div></li>
<li><p>Bayes classifier<br/></p></li>
<li><p>Support vector machines<br/></p></li>
<li><p>Optical character recognition</p></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="image-segmentation">Image segmentation</h2>
<ol style="list-style-type: decimal">
<li><p>Graph cuts<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy.misc <span class="im">import</span> imresize
<span class="im">from</span> PCV.tools <span class="im">import</span> graphcut
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>


<span class="kw">def</span> create_msr_labels(m, lasso<span class="op">=</span><span class="va">False</span>):
    <span class="co">&quot;&quot;&quot; Create label matrix for training from</span>
<span class="co">    user annotations. &quot;&quot;&quot;</span>
    labels <span class="op">=</span> zeros(im.shape[:<span class="dv">2</span>])
    <span class="co"># background</span>
    labels[m <span class="op">==</span> <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>
    labels[m <span class="op">==</span> <span class="dv">64</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>
    <span class="co"># foreground</span>
    <span class="cf">if</span> lasso:
        labels[m <span class="op">==</span> <span class="dv">255</span>] <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">else</span>:
        labels[m <span class="op">==</span> <span class="dv">128</span>] <span class="op">=</span> <span class="dv">1</span>
    <span class="cf">return</span> labels

<span class="co"># load image and annotation map</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;376043.jpg&#39;</span>))
m <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;376043.bmp&#39;</span>))
<span class="co"># resize</span>
scale <span class="op">=</span> <span class="fl">0.1</span>
im <span class="op">=</span> imresize(im, scale, interp<span class="op">=</span><span class="st">&#39;bilinear&#39;</span>)
m <span class="op">=</span> imresize(m, scale, interp<span class="op">=</span><span class="st">&#39;nearest&#39;</span>)
<span class="co"># create training labels</span>
labels <span class="op">=</span> create_msr_labels(m, <span class="va">False</span>)
<span class="co"># build graph using annotations</span>
g <span class="op">=</span> graphcut.build_bayes_graph(im, labels, kappa<span class="op">=</span><span class="dv">2</span>)

<span class="co"># cut graph</span>
res <span class="op">=</span> graphcut.cut_graph(g, im.shape[:<span class="dv">2</span>])
<span class="co"># remove parts in background</span>
res[m <span class="op">==</span> <span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>
res[m <span class="op">==</span> <span class="dv">64</span>] <span class="op">=</span> <span class="dv">1</span>

<span class="co"># plot the result</span>
figure()
imshow(res)
gray()
xticks([])
yticks([])
savefig(<span class="st">&#39;labelplot.pdf&#39;</span>)</code></pre></div></li>
<li><p>Segmentation using clustering<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools <span class="im">import</span> ncut
<span class="im">from</span> scipy.misc <span class="im">import</span> imresize
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image

im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;C-uniform03.ppm&#39;</span>))
m, n <span class="op">=</span> im.shape[:<span class="dv">2</span>]
<span class="co"># resize image to (wid,wid)</span>
wid <span class="op">=</span> <span class="dv">50</span>
rim <span class="op">=</span> imresize(im, (wid, wid), interp<span class="op">=</span><span class="st">&#39;bilinear&#39;</span>)
rim <span class="op">=</span> array(rim, <span class="st">&#39;f&#39;</span>)
<span class="co"># create normalized cut matrix</span>
A <span class="op">=</span> ncut.ncut_graph_matrix(rim, sigma_d<span class="op">=</span><span class="dv">1</span>, sigma_g<span class="op">=</span><span class="fl">1e-2</span>)
<span class="co"># cluster</span>
code, V <span class="op">=</span> ncut.cluster(A, k<span class="op">=</span><span class="dv">3</span>, ndim<span class="op">=</span><span class="dv">3</span>)

imshow(imresize(V[i].reshape(wid,wid),(m,n),interp<span class="op">=</span><span class="st">&#39;bilinear&#39;</span>))</code></pre></div></li>
<li><p>Variational methods<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> PCV.tools <span class="im">import</span> rof
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>
<span class="im">from</span> PIL <span class="im">import</span> Image
<span class="im">import</span> scipy.misc

<span class="co">#im = array(Image.open(&#39;../data/ceramic-houses_t0.png&#39;).convert(&quot;L&quot;))</span>
im <span class="op">=</span> array(Image.<span class="bu">open</span>(<span class="st">&#39;../data/flower32_t0.png&#39;</span>).convert(<span class="st">&quot;L&quot;</span>))
figure()
gray()
subplot(<span class="dv">131</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(im)

U, T <span class="op">=</span> rof.denoise(im, im, tolerance<span class="op">=</span><span class="fl">0.001</span>)
subplot(<span class="dv">132</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(U)

<span class="co">#t = 0.4  # ceramic-houses_t0 threshold</span>
t <span class="op">=</span> <span class="fl">0.8</span>  <span class="co"># flower32_t0 threshold</span>
seg_im <span class="op">=</span> U <span class="op">&lt;</span> t<span class="op">*</span>U.<span class="bu">max</span>()
<span class="co">#scipy.misc.imsave(&#39;ceramic-houses_t0_result.pdf&#39;, seg_im)</span>
scipy.misc.imsave(<span class="st">&#39;flower32_t0_result.pdf&#39;</span>, seg_im)
subplot(<span class="dv">133</span>)
axis(<span class="st">&#39;off&#39;</span>)
imshow(seg_im)

show()</code></pre></div></li>
<li><p>Exercises</p></li>
</ol>
<h2 id="opencv">OpenCV</h2>
<ol style="list-style-type: decimal">
<li><p>The opencv python interface<br/></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cv2 <span class="co"># the new module is available as</span>
<span class="im">import</span> cv <span class="co"># the old module can be accessed as</span></code></pre></div></li>
<li>Opencv basics<br/>
<ol style="list-style-type: decimal">
<li>Reading and writing images<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cv2
im <span class="op">=</span> cv2.imread(<span class="st">&#39;../data/empire.jpg&#39;</span>)<span class="co"># 读入图像</span>
h, w <span class="op">=</span> im.shape[:<span class="dv">2</span>]
<span class="bu">print</span> h, w <span class="co"># 打印图像尺寸</span>
cv2.imwrite(<span class="st">&#39;../images/ch10/ch10_P210_Reading-and-Writing-Images.png&#39;</span>,im)<span class="co"># 保存原jpg格式的图像为png格式图像</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Color spaces<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">im <span class="op">=</span> cv2.imread(<span class="st">&#39;empire.jpg&#39;</span>)
<span class="co"># create a grayscale version</span>
gray <span class="op">=</span> cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
<span class="co">#cv2.COLOR_BGR2GRAY</span>
<span class="co">#cv2.COLOR_BGR2RGB</span>
<span class="co">#cv2.COLOR_GRAY2BGR</span></code></pre></div>
<ol start="3" style="list-style-type: decimal">
<li>Displaying images and results<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># -*- coding: utf-8 -*-</span>
<span class="im">import</span> cv2
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

im <span class="op">=</span> cv2.imread(<span class="st">&#39;../data/fisherman.jpg&#39;</span>)<span class="co"># 读入图像</span>
gray <span class="op">=</span> cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)<span class="co"># 转换颜色空间</span>

fig <span class="op">=</span> plt.figure()<span class="co"># 显示积分图像</span>
subplot(<span class="dv">121</span>)
plt.gray()
imshow(gray)
title(<span class="st">u&#39;灰度图&#39;</span>, fontproperties<span class="op">=</span>font)
axis(<span class="st">&#39;off&#39;</span>)

intim <span class="op">=</span> cv2.integral(gray)<span class="co"># 计算积分图像</span>
intim <span class="op">=</span> (<span class="fl">255.0</span><span class="op">*</span>intim) <span class="op">/</span> intim.<span class="bu">max</span>()<span class="co"># 归一化</span>

subplot(<span class="dv">122</span>)<span class="co">#显示积分图像</span>
plt.gray()
imshow(intim)
title(<span class="st">u&#39;积分图&#39;</span>, fontproperties<span class="op">=</span>font)
axis(<span class="st">&#39;off&#39;</span>)
show()

cv2.imshow(<span class="st">&quot;Image&quot;</span>, intim)<span class="co"># 用OpenCV显示图像</span>
cv2.waitKey()

cv2.imwrite(<span class="st">&#39;../images/ch10/ch10_P211_Displaying-Images-and-Results-cv2.jpg&#39;</span>,intim)<span class="co"># 用OpenCV保存积分图像</span>

fig.savefig(<span class="st">&quot;../images/ch10/ch10_P211_Displaying-Images-and-Results.png&quot;</span>)<span class="co"># 保存figure中的灰度图像和积分图像</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cv2
<span class="im">import</span> numpy
<span class="im">from</span> pylab <span class="im">import</span> <span class="op">*</span>

filename <span class="op">=</span> <span class="st">&#39;../data/fisherman.jpg&#39;</span><span class="co"># 读入图像</span>
im <span class="op">=</span> cv2.imread(filename)
rgbIm <span class="op">=</span> cv2.cvtColor(im, cv2.COLOR_BGR2RGB)<span class="co"># 转换颜色空间</span>

fig <span class="op">=</span> plt.figure()<span class="co"># 显示原图</span>
subplot(<span class="dv">121</span>)
plt.gray()
imshow(rgbIm)
title(<span class="st">u&#39;原图&#39;</span>, fontproperties<span class="op">=</span>font)
axis(<span class="st">&#39;off&#39;</span>)

h, w <span class="op">=</span> im.shape[:<span class="dv">2</span>]<span class="co"># 获取图像尺寸</span>
diff <span class="op">=</span> (<span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">6</span>)<span class="co"># 泛洪填充</span>
mask <span class="op">=</span> zeros((h<span class="dv">+2</span>, w<span class="dv">+2</span>), numpy.uint8)
cv2.floodFill(im, mask, (<span class="dv">10</span>, <span class="dv">10</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">0</span>), diff, diff)

subplot(<span class="dv">122</span>)<span class="co"># 显示泛洪填充后的结果</span>
imshow(im)
title(<span class="st">u&#39;泛洪填充&#39;</span>, fontproperties<span class="op">=</span>font)
axis(<span class="st">&#39;off&#39;</span>)

show()
fig.savefig(<span class="st">&quot;../images/ch10/floodFill.png&quot;</span>)

<span class="co">#在OpenCV窗口中显示泛洪填充后的结果</span>
cv2.imshow(<span class="st">&#39;flood fill&#39;</span>, im)
cv2.waitKey()
cv2.imwrite(<span class="st">&#39;../images/ch10/floodFill.jpg&#39;</span>,im)<span class="co"># 保存结果</span></code></pre></div></li>
<li><p>Processing video<br/></p>
<ol style="list-style-type: decimal">
<li>Video input<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cv2

<span class="co"># setup video capture</span>
cap <span class="op">=</span> cv2.VideoCapture(<span class="dv">0</span>)
cap.<span class="bu">open</span>(<span class="dv">0</span>)
<span class="cf">while</span> <span class="va">True</span>:
    ret,im <span class="op">=</span> cap.read()
    cv2.imshow(<span class="st">&#39;video test&#39;</span>,im)
    key <span class="op">=</span> cv2.waitKey(<span class="dv">10</span>)
    <span class="cf">if</span> key <span class="op">==</span> <span class="dv">27</span>:
        <span class="cf">break</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Reading video to NumPy arrays<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scipy <span class="im">import</span> <span class="op">*</span>
<span class="im">import</span> cv2

<span class="co"># setup video capture</span>
cap <span class="op">=</span> cv2.VideoCapture(<span class="dv">0</span>)
cap.<span class="bu">open</span>(<span class="dv">0</span>)
<span class="cf">if</span> cap.isOpened():
  <span class="bu">print</span> <span class="st">&quot;Finally&quot;</span>
<span class="cf">else</span>:
  <span class="bu">print</span> <span class="st">&quot;BOOM&quot;</span>
frames <span class="op">=</span> []
<span class="co"># get frame, store in array</span>
<span class="cf">while</span> <span class="va">True</span>:
    ret, im <span class="op">=</span> cap.read()
    cv2.imshow(<span class="st">&#39;video&#39;</span>, im)
    frames.append(im)
    <span class="cf">if</span> cv2.waitKey(<span class="dv">10</span>) <span class="op">==</span> <span class="dv">27</span>:
      <span class="cf">break</span>
frames <span class="op">=</span> array(frames)
<span class="co"># check the sizes</span>
<span class="bu">print</span> im.shape
<span class="bu">print</span> frames.shape</code></pre></div></li>
<li>Tracking<br/>
<ol style="list-style-type: decimal">
<li>Optical flow<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> cv2

<span class="kw">def</span> draw_flow(im,flow,step<span class="op">=</span><span class="dv">16</span>):
    <span class="co">&quot;&quot;&quot; Plot optical flow at sample points</span>
<span class="co">    spaced step pixels apart. &quot;&quot;&quot;</span>
    h,w <span class="op">=</span> im.shape[:<span class="dv">2</span>]
    y,x <span class="op">=</span> mgrid[step<span class="op">/</span><span class="dv">2</span>:h:step,step<span class="op">/</span><span class="dv">2</span>:w:step].reshape(<span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>)
    fx,fy <span class="op">=</span> flow[y,x].T
    <span class="co"># create line endpoints</span>
    lines <span class="op">=</span> vstack([x,y,x<span class="op">+</span>fx,y<span class="op">+</span>fy]).T.reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)
    lines <span class="op">=</span> int32(lines)
    <span class="co"># create image and draw</span>
    vis <span class="op">=</span> cv2.cvtColor(im,cv2.COLOR_GRAY2BGR)
    <span class="cf">for</span> (x1,y1),(x2,y2) <span class="op">in</span> lines:
        cv2.line(vis,(x1,y1),(x2,y2),(<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>),<span class="dv">1</span>)
        cv2.circle(vis,(x1,y1),<span class="dv">1</span>,(<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>), <span class="op">-</span><span class="dv">1</span>)
    <span class="cf">return</span> vis

<span class="co"># setup video capture</span>
cap <span class="op">=</span> cv2.VideoCapture(<span class="dv">0</span>)
ret,im <span class="op">=</span> cap.read()
prev_gray <span class="op">=</span> cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
<span class="cf">while</span> <span class="va">True</span>:
    <span class="co"># get grayscale image</span>
    ret,im <span class="op">=</span> cap.read()
    gray <span class="op">=</span> cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)
    <span class="co"># compute flow</span>
    flow <span class="op">=</span> cv2.calcOpticalFlowFarneback(prev_gray,gray,<span class="va">None</span>,<span class="fl">0.5</span>,<span class="dv">3</span>,<span class="dv">15</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="fl">1.2</span>,<span class="dv">0</span>)
    prev_gray <span class="op">=</span> gray
    <span class="co"># plot the flow vectors</span>
    cv2.imshow(<span class="st">&#39;Optical flow&#39;</span>,draw_flow(gray,flow))
    <span class="cf">if</span> cv2.waitKey(<span class="dv">10</span>) <span class="op">==</span> <span class="dv">27</span>:
        <span class="cf">break</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>The Lucas-Kanade Algorithm<br/></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> lktrack

imnames <span class="op">=</span> [<span class="st">&#39;../data/bt/bt.003.pgm&#39;</span>, <span class="st">&#39;../data/bt/bt.002.pgm&#39;</span>, <span class="st">&#39;../data/bt/bt.001.pgm&#39;</span>, <span class="st">&#39;../data/bt/bt.000.pgm&#39;</span>]
<span class="co"># create tracker object</span>
lkt <span class="op">=</span> lktrack.LKTracker(imnames)
<span class="co"># detect in first frame, track in the remaining</span>
lkt.detect_points()
lkt.draw()
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="bu">len</span>(imnames)<span class="op">-</span><span class="dv">1</span>):
    lkt.track_points()
    lkt.draw()</code></pre></div></li>
<li><p>More examples</p></li>
</ol>
</body>
</html>
