<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h2 id="数字图像处理--形态学处理"><span style="color:red"><strong><em>数字图像处理--形态学处理</em></strong></span></h2>
<p>数学形态学是一门建立在集论基础上的学科，是几何形态学分析和描述的有力工具。数学形态学的历史可回溯到19世纪。1964年法国的Matheron和Serra在积分几何的研究成果上，将数学形态学引入图像处理领域，并研制了基于数学形态学的图像处理系统。1982年出版的专著《Image Analysis and Mathematical Morphology》是数学形态学发展的重要里程碑，表明数学形态学在理论上趋于完备及应用上不断深入。数学形态学蓬勃发展，由于其并行快速，易于硬件实现，已引起了人们的广泛关注。目前，数学形态学已在计算机视觉、信号处理与图像分析、模式识别、计算方法与数据处理等方面得到了极为广泛的应用。</p>
<p>数学形态学可以用来解决<span style="color:red"><strong><em>抑制噪声、特征提取、边缘检测、图像分割、形状识别、纹理分析、图像恢复与重建、图像压缩等图像处理问题</em></strong></span>。该文将主要对数学形态学的基本理论及其在图像处理中的应用进行综述。</p>
<p>数学形态学是以形态结构元素为基础对图像进行分析的数学工具。它的基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的。数学形态学的应用可以简化图像数据，保持它们基本的形状特征，并除去不相干的结构。数学形态学的基本运算有4个：<span style="color:red"><strong><em>膨胀、腐蚀、开启和闭合</em></strong></span>。它们在二值图像中和灰度图像中各有特点。基于这些基本运算还可以推导和组合成各种数学形态学实用算法。</p>
<h3 id="腐蚀和膨胀"><span style="color:red"><strong><em>腐蚀和膨胀</em></strong></span></h3>
<p>最基本的形态学操作有二种，他们是：膨胀与腐蚀(Dilation与Erosion)。 膨胀与腐蚀能实现多种多样的功能，主要如下： - 消除噪声 - 分割(isolate)出独立的图像元素，在图像中连接(join)相邻的元素。 - 寻找图像中的明显的极大值区域或极小值区域 - 求出图像的梯度 通过以下图像，我们简要来讨论一下膨胀与腐蚀操作(译者注：注意这张图像中的字母为黑色，背景为白色，而不是一般意义的背景为黑色，前景为白色）:</p>
<ol style="list-style-type: decimal">
<li><span style="color:red"><strong><em>腐蚀</em></strong></span> 作为<span class="math inline">\(Z^2\)</span>中的集合Ａ和Ｂ，表示为: <span class="math display">\[A\ominus B=\{z|(B)_z \subseteq A\}\]</span> 表面上，该式指出Ｂ对Ａ的腐蚀是一个用z平移的Ｂ包含在Ａ中所有点的集合．在下面的讨论中，假定集合Ｂ是一个结构元，因为Ｂ必须包含在Ａ中这一陈述等价于Ｂ不与北京共享任何公共元素，所以可以将腐蚀表达为：<span class="math inline">\(A\ominus B=\{z|(B)_z\cap A^c=\varnothing\}\)</span>, <span class="math inline">\(A^c\)</span>是Ａ的补集，<span class="math inline">\(\varnothing\)</span>是空集．</li>
<li><span style="color:red"><strong><em>膨胀</em></strong></span> A和Ｂ是<span class="math inline">\(Z^2\)</span>中的集合，表示<span class="math inline">\(A\oplus B\)</span>的Ｂ对A的膨胀定义为： <span class="math display">\[A\oplus B=\{z|(\hat{B})_z \cap A \ne \varnothing \}\]</span> 该公式是以Ｂ关于它原点的映像，并且以z对映像进行平移为基础．Ｂ对Ａ的膨胀是所有平移z的集合．这样，<span class="math inline">\(\hat{B}\)</span>和<span class="math inline">\(A\)</span>至少有一个元素是重叠的．根据这种解释，上式可以等价为: <span class="math display">\[A\oplus B=\{z|[(\hat{B})_z \cap A]\subseteq A \}\]</span></li>
<li><span style="color:red"><strong><em>对偶性</em></strong></span> 膨胀和腐蚀彼此关于集合求补运算和反射运算是对偶的，即： <span class="math display">\[(A\ominus B)^c=A^c\oplus B^c\]</span> <span class="math display">\[(A\oplus B)^c=A^c\ominus B^c\]</span> 上式指出，Ｂ对Ａ的腐蚀是<span class="math inline">\(\hat{B}\)</span>对<span class="math inline">\(A^c\)</span>的膨胀的补，反之亦然． ### <span style="color:red"><strong><em>开操作和闭操作</em></strong></span> 正如上面所示，膨胀会扩大一幅图像的组成部分，而腐蚀会缩小一幅图像的组成部分．另外的２个形态学操作是：开操作和闭操作． 结构元Ｂ对集合Ａ的开操作，表示为：<span class="math inline">\(A\circ B=(A\ominus B)\oplus B\)</span> 因此，Ｂ对Ａ的开操作就是Ｂ对Ａ的腐蚀，紧接着用Ｂ对结果进行膨胀． 类似的，用结构元Ｂ对集合Ａ的闭操作，表示为<span class="math inline">\(A\bullet B=(A\oplus B)\ominus B\)</span> 上式说明，Ｂ对集合Ａ的闭操作就是简单的用Ｂ对Ａ膨胀，紧接着用Ｂ对结果进行腐蚀．</li>
</ol>
<h3 id="击中或击不中变换"><span style="color:red"><strong><em>击中或击不中变换</em></strong></span></h3>
<p>击中或击不中变换是形态检测的一个基本工具。是一个整体，方法中包括击中部分跟击不中部分。 <span class="math inline">\(\begin{cases} A\circledast B=(A\ominus D)\cap [A^c\ominus (W-D)]\\ A\circledast B=(A\ominus B_1)\cap (A^c\ominus B_2)\\ A\circledast B=(A\ominus B_1)\cap (A\oplus \hat{B}_2) \end{cases}\)</span></p>
<h3 id="一些基本的形态学算法"><span style="color:red"><strong><em>一些基本的形态学算法</em></strong></span></h3>
<ol style="list-style-type: decimal">
<li><span style="color:red"><strong><em>边界提取</em></strong></span> 表示为<span class="math inline">\(\beta(A)\)</span>的集合Ａ的边界可以通过先用Ｂ对Ａ腐蚀，然后执行Ａ和腐蚀的结果进行集合之差得到，即<span class="math display">\[\beta(A)=A-(A\ominus B)\]</span></li>
<li><span style="color:red"><strong><em>孔洞填充</em></strong></span> 令Ａ是一个集合，其元素是８连通的边界，每个边界包围一个背景区域（即一个孔洞）．当给定每个空洞中的一个点后，目的就是用１填充所有的空洞． 除了在每一个孔洞中对应于<span class="math inline">\(X_0\)</span>中的位置给定的点之外，这一点我们已经设置为１了，我们从形成一个由０组成的阵列<span class="math inline">\(X_0\)</span>开始．然后，如下过程将用１填充所有的孔洞： <span class="math display">\[X_k=(X_{k-1}\oplus B)\cap A^c,k=1,2,3,...\]</span></li>
<li><span style="color:red"><strong><em>连通分量的提取</em></strong></span> 令Ａ是包含一个或多个连通分量的集合，并形成一个阵列<span class="math inline">\(X_0\)</span>，除了在对应于Ａ中每个连通分量中的一个点的已知的每一个位置处我们已置为１（前景值）外，该阵列的所有其他元素均为０（背景值）．如下迭代过程可完成这一目的． <span class="math display">\[X_k=(X_{k-1}\oplus B)\cap A,k=1,2,3,...\]</span></li>
<li><span style="color:red"><strong><em>凸壳</em></strong></span> 如果在集合Ａ内连接任意２个点的直线段都在Ａ的内部，则称集合Ａ是凸形的．任意集合Ｓ的凸壳Ｈ是包含于Ｓ的最小凸壳．集合差<span class="math inline">\(H-S\)</span>称为Ｓ的凸缺．凸壳和凸缺对于物体描绘是很有用的．这里介绍一种获得集合Ａ的凸壳C(A)的简单形态学算法： <span class="math display">\[X_k^i=(X_{k-1}\circledast B^i)\cup A, i=1,2,3,4\text{ and }k=1,2,3,...\]</span> 其中，<span class="math inline">\(X_0^i=A\)</span>．当该过程收敛时（即当<span class="math inline">\(X_k^i=X_{k-1}^i\)</span>时），我们令<span class="math inline">\(D^i=X_k^i\)</span>.则A的凸壳为: <span class="math display">\[C(A)=\bigcup_{i=1}^4 D^i\]</span></li>
<li><span style="color:red"><strong><em>细化</em></strong></span> 结构元Ｂ对集合Ａ的细化可以表示为<span class="math inline">\(A\circledast B\)</span>,它可以根据击中或不击中变换来定义： <span class="math display">\[A\otimes B=A-\{A\circledast B\}=A\cap (A\circledast B)^c\]</span></li>
<li><span style="color:red"><strong><em>粗化</em></strong></span> 粗化是细化的形态学对偶，定义如下: <span class="math display">\[A\bullet B=A\cup (A\circledast B)=((...((A\odot B^1)\odot B^2)...)\odot B^n)\]</span></li>
<li><span style="color:red"><strong><em>骨架</em></strong></span> 集合A的骨架S(A)的概念直观上相当简单，由该图我们可以推出： (a)如果<span class="math inline">\(z\)</span>是S(A)的一个点，并且<span class="math inline">\((D)_z\)</span>是A内以z为中心的最大圆盘，则不存在包含<span class="math inline">\((D)_z\)</span>且位于A内的更大圆盘（不必以z为中心）。圆盘<span class="math inline">\((D)_z\)</span>为最大圆盘。 (b)圆盘<span class="math inline">\((D)_z\)</span>在两个或多个不同的位置与A的边界接触。 A的骨架可以用腐蚀和开操作来表达，即估计可以表达为: <span class="math display">\[S(A)=\bigcup_{k=0}^KS_k(A)\]</span> 其中，<span class="math inline">\(S_k(A)=(A\ominus kB)-(A\ominus kB)\circ B\)</span></li>
<li><span style="color:red"><strong><em>裁剪</em></strong></span> 裁剪方法本质上是对细化和骨架算法的补充，因为这些过程会保留某些寄生分量，因而需要用后处理清楚这些寄生分量。</li>
<li><span style="color:red"><strong><em>形态学重建</em></strong></span> 形态学重建是一种强有力的形态学变换，它涉及2幅图像和一个结构元。一幅图像是标记，它包含变换的起始点，另一幅图像是模板，它约束该变换。结构元用来定义连接性：</li>
<li><span style="color:red"><strong><em>二值图像形态学操作小结</em></strong></span></li>
</ol>
<h3 id="灰度级形态学"><span style="color:red"><strong><em>灰度级形态学</em></strong></span></h3>
<ol style="list-style-type: decimal">
<li><span style="color:red"><strong><em>腐蚀和膨胀</em></strong></span> 结构元素b对一幅图像<span class="math inline">\(f\)</span>在位置<span class="math inline">\((x,y)\)</span>处的腐蚀由下式给出： <span class="math inline">\([f\ominus b](x,y)=min\{f(x+s,y+t)\}\)</span></li>
<li><span style="color:red"><strong><em>开操作和闭操作</em></strong></span> 结构元b对图像f的开操作表示为:<span class="math inline">\(f\circ b=(f\ominus b)\oplus b\)</span></li>
<li><span style="color:red"><strong><em>一些基本的灰度级形态学算法</em></strong></span>
<ol style="list-style-type: decimal">
<li>形态学平滑</li>
<li>形态学梯度</li>
<li>顶帽变换和底帽变换</li>
<li>纹理分割</li>
</ol></li>
<li><span style="color:red"><strong><em>灰度级形态学重建</em></strong></span></li>
</ol>
<p><span style="color:red"><strong>Reference:</strong></span> <a href="http://blog.csdn.net/app_12062011/article/details/27351043">图像形态学变换</a> / <a href="http://blog.csdn.net/carson2005/article/details/34535173">膨胀-C代码</a> / <a href="http://blog.csdn.net/xiucaijiang/article/details/6250283">OpenCV形态学操作 腐蚀 膨胀 开闭</a> / <a href="http://blog.sina.com.cn/s/blog_650b273301017nvx.html">学习opencv——形态学操作（腐蚀膨胀、开闭运算）</a> / <a href="http://blog.sina.com.cn/s/blog_4b9b714a0100c9f8.html">opencv图像处理-采样、插值和几何变换</a></p>
</body>
</html>
