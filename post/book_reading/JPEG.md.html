<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="jpeg">JPEG</h1>
<h2 id="causal-prediction-methods因果预测方法">Causal Prediction Methods/因果预测方法</h2>
<ol style="list-style-type: decimal">
<li><p>因果预测方法: <font style="color:red">1D causal predict reules</font>: <span class="math inline">\(\hat{x}_i=p_i+q_i=\hat{x}_{i-1}+q_i\)</span> <font style="color:red">2D causal predict reules</font>: <span class="math inline">\(q_{ij}=w_1\hat{x}_{i-1,j}+w_2\hat{x}_{i,j-1}+w_3\hat{x}_{i-1,j-1}\)</span></p></li>
<li><p>Transform Coding: 是一种很流行的压缩编码的方式。设一个图像原始VLAD矩阵（uncompressed matrix）A为<span class="math inline">\(64\times 64\)</span>维。经过PCA降维以后为<span class="math inline">\(1\times 64\)</span>，设为矩阵B。注意到B是经过PCA降维后得到的，因此其已经过eigenvector的排序，其主成分靠前。TC编码器会根据算法为B的每一维分配<span class="math inline">\(n\)</span>个bit来储存编码。其类心的个数为<span class="math inline">\(2^n\)</span>。最后有很多维得出的<span class="math inline">\(n=0\)</span>，舍去。如为第一维分配3个bit，则第一维需训练8个类心。47位置后n=0，舍去，则最后的向量变为了47维。而算法中巧妙的在于，所有的n（n1，n2...n47）之和正好为64（原维度）。找出每个维度对应的类心，如第一维对应的是7，第二维是3，等等等等。因此所得向量为（7，3，...,1,1）共47维。而7按位展开为111，正好是3位，（还有000，001，010等类心）。因此最后每幅图像用64bits保存，便可以搞定。最后query时也有一些要注意的地方。 （1）将query向量与类心算距离，并保存。 （2）最后判断query与base中向量谁近时，用非对称距离 ，而不是对称距离计算（即用对应类心的距离之和）。 因此，TC将图像的压缩存储以及query都很好的解决了。</p></li>
<li><p>Block-based coding: 是将image分成多个小模块，然后对每个模块分别进行de-correlated(去相关)，　这种效果几乎和原尺寸图像decorrelation效果一样好。目前一些标准的(JPEG,MPEG)都是用的<span class="math inline">\(8\times 8\)</span> DCT blocks.</p></li>
</ol>
<h2 id="jpeg-1">JPEG</h2>
<p>和transform不一样，JPEG是基于块的转换编码，基于块的DCT可以获得接近整图的效果。JPEG 是基于ISO 10918的，发布于1992,　提供了一个<font style="color:red">压缩连续色调静态图像</font>的方法。JPEG的主要应用是将静态图像压缩后进行存储和传输。JPEG coder的一些特征有： - 在JPEG compression中<font style="color:red">很多的特征是可选的（例如编码表）</font> - 只定义了<font style="color:red">标准的输入输出</font>熟悉，但是算法细节不做限制。我们可以用Huffman或者用算术编码。 - JPEG compression确实提供了一个<font style="color:red">baseline</font>实现，然而，并没有人follow!!!</p>
<p><strong>JPEG Baseline编码方法</strong>：JPEG baseline压缩是一个基于<font style="color:red">颜色空间转换</font>和DCT的 <strong>LOSSY</strong> 压缩架构，JPEG作用在真彩色(<strong>24</strong> bits per pixel)的连续色调图像上，能获得 <strong>25:1</strong> 的压缩率（没有太多视觉质量的损失）。 <img src="http://www.graphicsmill.com/docs/gm5/JPEGschema.png" /></p>
<ol style="list-style-type: decimal">
<li><font style="color:red">图像分割</font> JPEG算法的第一步，图像被分割成大小为<font style="color:red">8X8的小块</font>，这些小块在整个压缩过程中都是单独被处理的。</li>
<li><font style="color:red">颜色空间转换<span class="math inline">\(RGB-&gt;YC_bC_r\)</span></font> 所谓“颜色空间”，是指表达颜色的数学模型，比如我们常见的“RGB”模型，就是把颜色分解成红绿蓝三种分量，这样一张图片就可以分解成三张灰度图，数学表达上，每一个8X8的图案，可以表达成三个8X8的矩阵，其中的数值的范围一般在[0,255]之间。</br> 不同的颜色模型各有不同的应用场景，例如RGB模型适合于像显示器这样的自发光图案，而在印刷行业，使用油墨打印，图案的颜色是通过在反射光线时产生的，通常使用CMYK模型，而在JPEG压缩算法中，需要把图案转换成为<span class="math inline">\(YC_bC_r\)</span>模型，这里的Y表示亮度(Luminance)，<span class="math inline">\(C_b\)</span>和<span class="math inline">\(C_r\)</span>分别表示绿色和红色的“色差值”。</br> 根据三基色原理，人们发现红绿蓝三种颜色所贡献的亮度是不同的，绿色的“亮度”最大，蓝色最暗，设红色所贡献的亮度的份额为<span class="math inline">\(K_R\)</span>，蓝色贡献的份额为<span class="math inline">\(K_B\)</span>，那么亮度为: <span class="math inline">\(Y=K_R.R+(1-K_R-K_B).G+K_B.B\)</span> (根据经验，<span class="math inline">\(K_R=0.299\)</span>，<span class="math inline">\(K_B=0.114\)</span>)，那么 : <span class="math inline">\(Y=0.299\cdot R+0.587\cdot G+0.114\cdot B\)</span>, 蓝色和红色的色差的定义: <span class="math inline">\(\begin{cases}C_b=\frac{1}{2}\cdot \frac{B-Y}{1-K_B}\\C_r=\frac{1}{2}\cdot\frac{R-Y}{1-K_R}\end{cases}\)</span>. 最终可以得到RGB转换为YCbCr的数学公式为: <span class="math inline">\(\begin{cases}Y=0.299R+0.587G+0.114B\\Cb=-0.1687R-0.3313G+0.5B+128\\Cr=0.5R-0.4187G-0.0813B+128\end{cases}\)</span>. </br> YCbCr模型广泛应用在图片和视频的压缩传输中，比如你可以留意一下电视或者DVD后面的接口，就可以发现色差接口。</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_14.jpg" /> 这是有道理的，<font style="color:red">还记得我们在文章开始时提到的有损压缩的基本原理吗？</font>有损压缩首先要做的事情就是“<font style="color:red">把重要的信息和不重要的信息分开</font>”，YCbCr恰好能做到这一点。对于人眼来说，图像中明暗的变化更容易被感知到，这是由于人眼的构造引起的。<font style="color:red">视网膜上有两种感光细胞，能够感知亮度变化的视杆细胞，以及能够感知颜色的视锥细胞，由于视杆细胞在数量上远大于视锥细胞，所以我们更容易感知到明暗细</font>节。比如说下面这张图</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_15.jpg" /></br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_16.jpg" /><img src="http://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_17.jpg" /><img src="http://thecodeway.com/blog/wp-content/uploads/2014/08/jpeg_18.jpg" /></br> 可以明显看到，亮度图的细节更加丰富。JPEG把图像转换为<span class="math inline">\(YC_bC_r\)</span>之后，就可以针对数据得重要程度的不同做不同的处理。这就是为什么JPEG使用这种颜色空间的原因</li>
<li><font style="color:red">颜色空间的下采样</font> 一幅颜色图像(<span class="math inline">\(Y,C_b,C_r\)</span>)是下采样的，所以一个(色度)模块对应着４个Y(亮度)模块。　$
\begin{cases}
MCU_1=Y_{00}Y_{01}Y_{10}Y_{11}Cr_{00}Cb_{00}\\
MCU_2=Y_{02}Y_{03}Y_{12}Y_{13}Cr_{01}Cb_{01}
\end{cases}
$</br> <font style="color:red">Level Shifting</font>: 首先将输入数据进行偏移，这样是的图像的分布为０．例如：一个在０到255 8-bit输入样例通过减去128转换到-128:127范围内。</li>
<li><font style="color:red">前向DCT(Discrete cosine transform)</font> 离散余弦变换属于傅里叶变换的另外一种形式，没错，就是大名鼎鼎的傅里叶变换。傅里叶是法国著名的数学家和物理学家，1807年，39岁的傅里叶在他的一篇论文里提出了一个想法，他认为任何周期性的函数，都可以分解为为一系列的三角函数的组合.</br> <span class="math display">\[
{\displaystyle X_{k}=\sum _{n=0}^{N-1}x_{n}\cdot (\cos(-2\pi k{\frac {n}{N}})+i\sin(-2\pi k{\frac {n}{N}})),\quad k\in \mathbb {Z} \,}
\]</span> <font style="color:red">当我们要处理的不再是函数，而是一堆离散的数据时，并且这些数据是对称的话</font>，那么傅里叶变化出来的函数只含有<font style="color:red">余弦项</font>，这种变换称为离散余弦变换。举个例子，有一组一维数据<span class="math inline">\([x_0,x_1,x_2,\cdots,x_{n-1}]\)</span>,那么可以通过DCT变换得到 <span class="math inline">\(n\)</span> 个变换级数 <span class="math inline">\(F_i\)</span></br> <span class="math display">\[
F_m=\sum_{k=0}^{n-1}x_k\cos[\frac{\pi}{n}m(k+\frac{1}{2})]\Leftrightarrow x_m=\frac{F_0}{n}+\sum_{k=1}^{n-1}[\frac{2F_k}{n}\cos[\frac{\pi}{n}(m+\frac{1}{2})k]]
\]</span> 也就是说，<font style="color:red">经过DCT变换，可以把一个数组分解成数个数组的和</font>，如果我们数组视为一个一维矩阵，那么可以把结果看做是一系列矩阵的和</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_24.gif" /></br> 奥妙之处在于，<font style="color:red">经过DCT，数据中隐藏的规律被发掘了出来</font>,杂乱的数据被转换成几个工整变化的数据。DCT转换后的数组中第一个是一个直线数据，因此又被称为“直流数据”，简称DC，后面的数据被称为“交流数据”，简称AC，这个称呼起源于信号分析中的术语。 在JPEG压缩过程中，经过颜色空间的转换，每一个8X8的图像块，在数据上表现为3个8X8的矩阵，紧接着我们对这三个矩阵做一个二维的DCT转换，二维的DCT转换公式为</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_34.gif" /></br> DCT的威力究竟有多大，我们可以做一个实际的测试，比如一个所有数值都一样的矩阵，经过DCT转换后，将所有级数组合成一个新的矩阵</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_35.gif" /></br> 可以看到，经过DCT转换，矩阵的“能量”被全部集中在左上角上的直流分量F(0,0）上，其他位置都变成了0。在实际的JPEG压缩过程中，由于图像本身的连贯性，一个8X8的图像中的数值一般不会出现大的跳跃，经过DCT转换会有类似的效果，左上角的直流分量保存了一个大的数值，其他分量都接近于0，我们以Lenna左上角第一块图像的Y分量为例，经过变换的矩阵为</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_36.gif" /></br> 可以看到，数据经过DCT变化后，被明显分成了直流分量和交流分量两部分，为后面的进一步压缩起到了充分的铺垫作用，可以说是整个JPEG中最重要的一步，后面我们会介绍数据量化。</br> 一个<span class="math inline">\(8\times 8\)</span>的转换：<span class="math inline">\(F_{x,y}=\frac{C(x)C(y)}{4}\sum_{i=0}^7\sum_{j=0}^tf_{i,j}\cos (\frac{(2i+1)x\pi}{16})\cos (\frac{(2j+1)y\pi}{16})\)</span></br> 其中<span class="math inline">\(f_{i,j}\)</span>是输入样本模块的６４个采样数据<span class="math inline">\((i,j)\)</span>, <span class="math inline">\(F_{x,y}\)</span>是64DCT相关系数<span class="math inline">\((x,y)\)</span>　并且<span class="math inline">\(C(x),C(y)\)</span>都是常数:<span class="math inline">\(C(n)=\begin{cases}\frac{1}{\sqrt{2}},n=0 \\ 1, n\neq 0\end{cases}\)</span></br> <strong>Discrete Cosine Transform总结</strong> （1）<font style="color:green">能量压缩。top-left coefficients对应着低频率，在这个区域有一个很明细的能量“peak”，并且coefficient值很快下降。</font></br> （２）<font style="color:green">去相关。那些数值小的相关系数将会被丢弃，这种做法并不会影响图像质量。</font></br> （3）<font style="color:green">DCT已经被证明对大类图像压缩的优选，DCT是一个正交变换，它在对原始图像数据点进行去相关前先对图像进行<span class="math inline">\(8\times 8\)</span>的spatial representation。DCT的相关系数很容易被量化，且获得不错的压缩效果。DCT算法是对称的(Symmetrical)。</font></br></li>
<li><font style="color:red">Quantization/数据量化</font> 经过上一节介绍的离散余弦变换，图像数据虽然已经面目全非，但仍然是处于“可逆”的状态，也就是说我们还没有进入“有损”的那一步。这次我们来玩真的，看一下数据中的细节是如何被滤去的。先来考察一下要对付的问题是什么，经过颜色空间转换和离散余弦变换，每一个8X8的图像块都变成了三个8X8的浮点数矩阵，分别表示Y,Cr,Cb数据，比如以其中某个亮度数据矩阵举例，它的数据如下:</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_030.gif" /> 我们的问题是，在可以损失一部分精度的情况下，如何用更少的空间存储这些浮点数？答案是使用量子化（Quantization），简称量化。“量子”这个概念来自于物理学，意思是说连续的能量可以看做是一个个单元体的组合，看起来高端大气，其实很简单，比如游戏中在处理角色面朝方向时，一般并不是使用0到2π这样的浮点数，而是把方向分成16个区间，用0到16这样的整数来表示，这样只用4个bit就足够了。JPEG提供的量子化算法如下</br> <span class="math display">\[
B_{q_{ij}}=\text{round}(\frac{G_{ij}}{Q_{ij}})
\]</span> 其中G是我们需要处理的图像矩阵，Q称作量化系数矩阵（Quantization matrices），JPEG算法提供了两张标准的量化系数矩阵，分别用于处理亮度数据<span class="math inline">\(Y\)</span>和色差数据<span class="math inline">\(C_r\)</span>以及<span class="math inline">\(C_b\)</span>。</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_032.gif" /><img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_033.gif" /> 其中round函数是取整函数，但考虑到了四舍五入</br> 比如上面数据，以左上角的-415.38为例，对应的量子化系数是16，那么round(-415.38/16)=round(-25.96125)=-26。最终得到的量子化后的结果为</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_034.gif" /> 可以看到，一大部分数据变成了0，这非常有利于后面的压缩存储。这两张神奇的量化表也是有讲究的，还记得我们在第一节中所讲的有损压缩的基本原理吗，有损压缩就是把数据中重要的数据和不重要的数据分开，然后分别处理。DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据时人们根据人眼对不不同频率的敏感程度的差别所积累下的经验制定的，一般来说人眼对于低频的分量必高频分量更加敏感，所以两张量化系数矩阵左上角的数值明显小于右下角区域。在实际的压缩过程中，还可以根据需要在这些系数的基础上再乘以一个系数，以使更多或更少的数据变成0，我们平时使用的图像处理软件在省城jpg文件时，在控制压缩质量的时候，就是控制的这个系数。</br> 在进入下一节之前，矩阵的量化还有最后一步要做，就是把量化后的二维矩阵转变成一个一维数组，以方便后面的霍夫曼压缩，但在做这个顺序转换时，需要按照一个特定的取值顺序, 这一个步骤叫<strong>Zigzag Reordering</strong>(Zigzag Reordering)。</br> <img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/jpeg_036.gif" /> 这么做的目的只有一个，就是尽可能把0放在一起，由于0大部分集中在右下角，所以才去这种由左上角到右下角的顺序，经过这种顺序变换，最终矩阵变成一个整数数组:-26,-3,0,-3,-2,-6,2,-4,1,-3,0,1,5,,1,2,-1,1,-1,2,0,0,0,0,0,-1,-1,0,0,0,0,…,0,0.后面的工作就是对这个数组进行再一次的哈夫曼压缩，已得到最终的压缩数据。</br> 在实际的处理中，每次是按照<span class="math inline">\(8\times 8\)</span>模块一次处理的，并且按照颜色空间<span class="math inline">\(R,G,B\)</span> or <span class="math inline">\(Y, C_r,C_b\)</span>.</li>
<li>DC系数的差分脉冲调制编码 8<em>8的图像块经过DCT变换之后得到的DC系数有两个特点：</br> （1）系数的数值比较大；</br> （2）相邻的8</em>8图像块的DC系数值变化不大；</br> 根据这两个特点，DC系数一般采用差分脉冲调制编码DPCM（Difference Pulse Code Modulation），即：取同一个图像分量中每个DC值与前一个DC值的差值来进行编码。对差值进行编码所需要的位数会比对原值进行编码所需要的位数少了很多。假设某一个8<em>8图像块的DC系数值为15，而上一个8</em>8图像块的DC系数为12，则两者之间的差值为3。</br>
<ul>
<li>DC系数的中间格式计算: JPEG中为了更进一步节约空间，并不直接保存数据的具体数值，而是将数据按照位数分为16组，保存在表里面。这也就是所谓的变长整数编码VLI。即，第0组中保存的编码位数为0，其编码所代表的数字为0；第1组中保存的编码位数为1，编码所代表的数字为-1或者1......，如下面的表格所示，这里，暂且称其为VLI编码表： <img src="http://my.csdn.net/uploads/201207/17/1342454493_4379.png" /> 前面提到的那个DC差值为3的数据，通过查找VLI可以发现，整数3位于VLI表格的第2组，因此，可以写成（2）（3）的形式，该形式，称之为DC系数的中间格式。</li>
</ul></li>
<li>熵编码法/Entropy encoding (Huffman Code) <font style="color:red">JPEG压缩的最后一步是对数据进行哈弗曼编码(Huffman coding)</font>，哈弗曼几乎是所有压缩算法的基础，它的基本原理是<font style="color:red">根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。</font></br> 举个例子，比如下面这段数据: “AABCBABBCDBBDDBAABDBBDABBBBDDEDBD”</br> 这段数据里面包含了33个字符，每种字符出现的次数统计如下
<div align="center">
<table class="gridtable" style="width:450px; text-align: center; border-collapse: collapse;">
<tbody>
<tr>
<th>
<strong>字符</strong>
</th>
<td>
<strong>A</strong>
</td>
<td>
<strong>B</strong>
</td>
<td>
<strong>C</strong>
</td>
<td>
<strong>D</strong>
</td>
<td>
<strong>E</strong>
</td>
</tr>
<tr>
<th>
编码
</th>
<td>
001
</td>
<td>
010
</td>
<td>
011
</td>
<td>
100
</td>
<td>
101
</td>
</tr>
</tbody>
</table>
</div>
如果我们用我们常见的定长编码，每个字符都是3个bit。
<div align="center">
<table class="gridtable" style="width:450px; text-align: center; border-collapse: collapse;">
<tbody>
<tr>
<th>
<strong>字符</strong>
</th>
<td>
<strong>A</strong>
</td>
<td>
<strong>B</strong>
</td>
<td>
<strong>C</strong>
</td>
<td>
<strong>D</strong>
</td>
<td>
<strong>E</strong>
</td>
</tr>
<tr>
<th>
编码
</th>
<td>
001
</td>
<td>
010
</td>
<td>
011
</td>
<td>
100
</td>
<td>
101
</td>
</tr>
</tbody>
</table>
</div>
那么这段文字共需要3*33 = 99个bit来保存，但如果我们根据字符出现的概率，使用如下的编码
<div align="center">
<table class="gridtable" style="width:450px; text-align: center; border-collapse: collapse;">
<tbody>
<tr>
<th>
<strong>字符</strong>
</th>
<td>
<strong>A</strong>
</td>
<td>
<strong>B</strong>
</td>
<td>
<strong>C</strong>
</td>
<td>
<strong>D</strong>
</td>
<td>
<strong>E</strong>
</td>
</tr>
<tr>
<th>
编码
</th>
<td>
110
</td>
<td>
0
</td>
<td>
1110
</td>
<td>
10
</td>
<td>
1111
</td>
</tr>
</tbody>
</table>
</div></li>
</ol>
<p>那么这段文字共需要3<em>6 + 1</em>15 + 4<em>2 + 2</em>9 + 4*1 = 63个bit来保存，压缩比为63%，哈弗曼编码一般都是使用二叉树来生成的，这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。</p>
<div class="figure">
<img src="http://thecodeway.com/blog/wp-content/uploads/2014/09/hufman7.gif" />

</div>
我们回到JPEG压缩上，回顾上一节的内容，经过数据量化，我们现在要处理的数据是一串一维数组，举例如下：
<table class="gridtable" align="center" width="100%" style="border:1px; text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
<strong>①原始数据</strong>
</th>
<td>
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</td>
</tr>
</tbody>
</table>
在实际的压缩过程中，数据中的0出现的概率非常高，所以首先要做的事情，是对其中的0进行处理，把数据中的非零的数据，以及数据前面0的个数作为一个处理单元。
<table class="gridtable" align="center" width="100%" style="border:1px; text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
①原始数据
</th>
<td colspan="8">
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</td>
</tr>
<tr>
<th>
<strong>②RLE编码</strong>
</th>
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td>
0,0,…,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
</tbody>
</table>
如果其中某个单元的0的个数超过16，则需要分成每16个一组，如果最后一个单元全都是0，则使用特殊字符“EOB”表示，EOB意思就是“后面的数据全都是0”,
<table class="gridtable" align="center" width="100%" style="text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
①原始数据
</th>
<td colspan="8">
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</td>
</tr>
<tr>
<th rowspan="3">
<strong>②RLE编码</strong>
</th>
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td colspan="2">
0,0,…,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr>
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td>
0,0,…,0
</td>
<td>
0,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr>
<td>
(0,35)
</td>
<td>
(0,7)
</td>
<td>
(3,-6)
</td>
<td>
(0,-2)
</td>
<td>
(2,-9)
</td>
<td>
(15,0)
</td>
<td>
(2,8)
</td>
<td>
EOB
</td>
</tr>
</tbody>
</table>
其中（15,0）表示16个0，接下来我们要处理的是括号里右面的数字，这个数字的取值范围在-2047~2047之间，JPEG提供了一张标准的码表用于对这些数字编码：
<table class="gridtable" style="text-align:center;">
<tbody>
<tr>
<th colspan="2">
Value
</th>
<th>
Size
</th>
<th colspan="2">
Bits
</th>
</tr>
<tr>
<td align="center" colspan="2">
0
</td>
<td>
0
</td>
<td align="center" colspan="2">
–
</td>
</tr>
<tr>
<td align="right">
-1
</td>
<td align="left">
1
</td>
<td>
1
</td>
<td align="right">
0
</td>
<td align="left">
1
</td>
</tr>
<tr>
<td align="right">
-3,-2
</td>
<td align="left">
2,3
</td>
<td>
2
</td>
<td align="right">
00,01
</td>
<td align="left">
10,11
</td>
</tr>
<tr>
<td align="right">
-7,-6,-5,-4
</td>
<td align="left">
4,5,6,7
</td>
<td>
3
</td>
<td align="right">
000,001,010,011
</td>
<td align="left">
100,101,110,111
</td>
</tr>
<tr>
<td align="right">
-15,…,-8
</td>
<td align="left">
8,…,15
</td>
<td>
4
</td>
<td align="right">
0000,…,0111
</td>
<td align="left">
1000,…,1111
</td>
</tr>
<tr>
<td align="right">
-31,…,-16
</td>
<td align="left">
16,…,31
</td>
<td>
5
</td>
<td align="right">
0 0000,…,0 1111
</td>
<td align="left">
1 0000,…,1 1111
</td>
</tr>
<tr>
<td align="right">
-63,…,-32
</td>
<td align="left">
32,…,63
</td>
<td>
6
</td>
<td align="right">
00 0000,…
</td>
<td align="left">
…,11 1111
</td>
</tr>
<tr>
<td align="right">
-127,…,-64
</td>
<td align="left">
64,…,127
</td>
<td>
7
</td>
<td align="right">
000 0000,…
</td>
<td align="left">
…,111 1111
</td>
</tr>
<tr>
<td align="right">
-255,…,-128
</td>
<td align="left">
128,…,255
</td>
<td>
8
</td>
<td align="right">
0000 0000,…
</td>
<td align="left">
…,1111 1111
</td>
</tr>
<tr>
<td align="right">
-511,…,-256
</td>
<td align="left">
256,…,511
</td>
<td>
9
</td>
<td align="right">
0 0000 0000,…
</td>
<td align="left">
…,1 1111 1111
</td>
</tr>
<tr>
<td align="right">
-1023,…,-512
</td>
<td align="left">
512,…,1023
</td>
<td>
10
</td>
<td align="right">
00 0000 0000,…
</td>
<td align="left">
…,11 1111 1111
</td>
</tr>
<tr>
<td align="right">
-2047,…,-1024
</td>
<td align="left">
1024,…,2047
</td>
<td>
11
</td>
<td align="right">
000 0000 0000,…
</td>
<td align="left">
…,111 1111 1111
</td>
</tr>
</tbody>
</table>
<p>
        举例来说，第一个单元中的“35”这个数字，在表中的位置是长度为6的那组，所对应的bit码是“100011”，而“-6”的编码是”001″，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。
</p>
<table class="gridtable" align="center" width="100%" style="text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
①原始数据
</th>
<td colspan="8">
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</td>
</tr>
<tr>
<th rowspan="3">
<strong>②RLE编码</strong>
</th>
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td colspan="2">
0,0,…,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr style="padding: 3px 3px;">
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td>
0,0,…,0
</td>
<td>
0,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr>
<td>
(0,35)
</td>
<td>
(0,7)
</td>
<td>
(3,-6)
</td>
<td>
(0,-2)
</td>
<td>
(2,-9)
</td>
<td>
(15,0)
</td>
<td>
(2,8)
</td>
<td>
EOB
</td>
</tr>
<tr>
<th>
<strong>③BIT编码</strong>
</th>
<td>
(0,6, <em><b>100011</b></em>)
</td>
<td>
(0,3, <em><b>111</b></em>)
</td>
<td>
(3,3, <em><b>001</b></em>)
</td>
<td>
(0,2, <em><b>01</b></em>)
</td>
<td>
(2,4, <em><b>0110</b></em>)
</td>
<td>
(15,-)
</td>
<td>
(2,4, <em><b>1000</b></em>)
</td>
<td>
EOB
</td>
</tr>
</tbody>
</table>
<p>
        括号中前两个数字分都在0~15之间，所以这两个数可以合并成一个byte，高四位是前面0的个数，后四位是后面数字的位数。
</p>
<table class="gridtable" align="center" width="100%" style="text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
①原始数据
</th>
<td colspan="8">
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</td>
</tr>
<tr>
<th rowspan="3">
<strong>②RLE编码</strong>
</th>
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td colspan="2">
0,0,…,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr style="padding: 3px 3px;">
<td>
35
</td>
<td>
7
</td>
<td>
0,0,0,-6
</td>
<td>
-2
</td>
<td>
0,0,-9
</td>
<td>
0,0,…,0
</td>
<td>
0,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr>
<td>
(0,35)
</td>
<td>
(0,7)
</td>
<td>
(3,-6)
</td>
<td>
(0,-2)
</td>
<td>
(2,-9)
</td>
<td>
(15,0)
</td>
<td>
(2,8)
</td>
<td>
EOB
</td>
</tr>
<tr>
<th rowspan="2">
<strong>③BIT编码</strong>
</th>
<td>
(0,6, <em><b>100011</b></em>)
</td>
<td>
(0,3, <em><b>111</b></em>)
</td>
<td>
(3,3, <em><b>001</b></em>)
</td>
<td>
(0,2, <em><b>01</b></em>)
</td>
<td>
(2,4, <em><b>0110</b></em>)
</td>
<td>
(15,-)
</td>
<td>
(2,4, <em><b>1000</b></em>)
</td>
<td>
EOB
</td>
</tr>
<tr>
<td>
(0x6,<em><b>100011</b></em>)
</td>
<td>
(0x3,<em><b>111</b></em>)
</td>
<td>
(0x33,<em><b>001</b></em>)
</td>
<td>
(0x2,<em><b>01</b></em>)
</td>
<td>
(0x24,<em><b>0110</b></em>)
</td>
<td>
(0xF0,-)
</td>
<td>
(0x24,<em><b>1000</b></em>)
</td>
<td>
EOB
</td>
</tr>
</tbody>
</table>
<p>
        对于括号前面的数字的编码，就要使用到我们提到的哈弗曼编码了，比如下面这张表，就是一张针对数据中的第一个单元，也就是直流(DC)部分的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0~15之间。
</p>
<table class="gridtable" align="center" style="width:300px; text-align:left;">
<tbody>
<tr>
<th>
Length
</th>
<th>
Value
</th>
<th>
Bits
</th>
</tr>
<tr>
<td>
3 bits
</td>
<td>
04<br />05<br />03<br />02<br />06<br />01<br />00 (EOB)
</td>
<td>
000<br />001<br />010<br />011<br />100<br />101<br />110
</td>
</tr>
<tr>
<td>
4 bits
</td>
<td>
07
</td>
<td>
1110
</td>
</tr>
<tr>
<td>
5 bits
</td>
<td>
08
</td>
<td>
1111 0
</td>
</tr>
<tr>
<td>
6 bits
</td>
<td>
09
</td>
<td>
1111 10
</td>
</tr>
<tr>
<td>
7 bits
</td>
<td>
0A
</td>
<td>
1111 110
</td>
</tr>
<tr>
<td>
8 bits
</td>
<td>
0B
</td>
<td>
1111 1110
</td>
</tr>
</tbody>
</table>
<p>
        举例来说，示例中的DC部分的数据是0x06，对应的二进制编码是“100”，而对于后面的交流部分，取值范围在0~255之间，所以对应的哈弗曼表会更大一些
</p>
<table class="gridtable" align="center" style="width:300px; text-align:left;">
<tbody>
<tr>
<th>
Length
</th>
<th>
Value
</th>
<th>
Bits
</th>
</tr>
<tr>
<td>
2 bits
</td>
<td>
01<br />02
</td>
<td>
00<br />01
</td>
</tr>
<tr>
<td>
3 bits
</td>
<td>
03
</td>
<td>
100
</td>
</tr>
<tr>
<td>
4 bits
</td>
<td>
00 (EOB)<br />04<br />11
</td>
<td>
1010<br />1011<br />1100
</td>
</tr>
<tr>
<td>
5 bits
</td>
<td>
05<br />12<br />21
</td>
<td>
1101 0<br />1101 1<br />1110 0
</td>
</tr>
<tr>
<td>
6 bits
</td>
<td>
31<br />41
</td>
<td>
1110 10<br />1110 11
</td>
</tr>
<tr>
<td>
…
</td>
<td>
…
</td>
<td>
…
</td>
</tr>
<tr>
<td>
12 bits
</td>
<td>
24<br />33<br />62<br />72
</td>
<td>
1111 1111 0100<br />1111 1111 0101<br />1111 1111 0110<br />1111 1111 0111
</td>
</tr>
<tr>
<td>
15 bits
</td>
<td>
82
</td>
<td>
1111 1111 1000 000
</td>
</tr>
<tr>
<td>
16 bits
</td>
<td>
09<br />…<br />FA
</td>
<td>
1111 1111 1000 0010<br />…<br />1111 1111 1111 1110
</td>
</tr>
</tbody>
</table>
<p>
        这样经过哈弗曼编码，并且序列化后，最终数据成为如下形式
</p>
<table class="gridtable" align="center" width="100%" style="text-align:center;">
<tbody>
<tr>
<th style="width:80px;">
①原始数据
</th>
<td colspan="14">
<center>
35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0
<center>
</center>
</center>
</td>
</tr>
<tr>
<th rowspan="3">
<strong>②RLE编码</strong>
</th>
<td colspan="2">
35
</td>
<td colspan="2">
7
</td>
<td colspan="2">
0,0,0,-6
</td>
<td colspan="2">
-2
</td>
<td colspan="2">
0,0,-9
</td>
<td colspan="3">
0,0,…,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr style="padding: 3px 3px;">
<td colspan="2">
35
</td>
<td colspan="2">
7
</td>
<td colspan="2">
0,0,0,-6
</td>
<td colspan="2">
-2
</td>
<td colspan="2">
0,0,-9
</td>
<td>
0,0,…,0
</td>
<td colspan="2">
0,0,8
</td>
<td>
0,0,…,0
</td>
</tr>
<tr>
<td colspan="2">
(0,35)
</td>
<td colspan="2">
(0,7)
</td>
<td colspan="2">
(3,-6)
</td>
<td colspan="2">
(0,-2)
</td>
<td colspan="2">
(2,-9)
</td>
<td>
(15,0)
</td>
<td colspan="2">
(2,8)
</td>
<td>
EOB
</td>
</tr>
<tr>
<th rowspan="2">
<strong>③BIT编码</strong>
</th>
<td colspan="2">
(0,6, <em><b>100011</b></em>)
</td>
<td colspan="2">
(0,3, <em><b>111</b></em>)
</td>
<td colspan="2">
(3,3, <em><b>001</b></em>)
</td>
<td colspan="2">
(0,2, <em><b>01</b></em>)
</td>
<td colspan="2">
(2,4, <em><b>0110</b></em>)
</td>
<td>
(15,-)
</td>
<td colspan="2">
(2,4, <em><b>1000</b></em>)
</td>
<td>
EOB
</td>
</tr>
<tr>
<td colspan="2">
(0x6,<em><b>100011</b></em>)
</td>
<td colspan="2">
(0x3,<em><b>111</b></em>)
</td>
<td colspan="2">
(0x33,<em><b>001</b></em>)
</td>
<td colspan="2">
(0x2,<em><b>01</b></em>)
</td>
<td colspan="2">
(0x24,<em><b>0110</b></em>)
</td>
<td>
0xF0
</td>
<td colspan="2">
(0x24,<em><b>1000</b></em>)
</td>
<td>
EOB
</td>
</tr>
<tr>
<th>
<strong>④哈弗曼编码</strong>
</th>
<td>
<em><b>100</b></em>
</td>
<td>
<em><b>100011</b></em>
</td>
<td>
<em><b>100</b></em>
</td>
<td>
<em><b>111</b></em>
</td>
<td>
<em><b>1111 1111 0101</b></em>
</td>
<td>
<em><b>001</b></em>
</td>
<td>
<em><b>01</b></em>
</td>
<td>
<em><b>01</b></em>
</td>
<td>
<em><b>1111 1111 0100</b></em>
</td>
<td>
<em><b>0110</b></em>
</td>
<td>
<em><b>1111 1111 001</b></em>
</td>
<td>
<em><b>1111 1111 0100</b></em>
</td>
<td>
<em><b>1000</b></em>
</td>
<td>
<em><b>1010</b></em>
</td>
</tr>
<tr>
<th rowspan="2">
⑤序列化
</th>
<td colspan="14">
<center>
100100011100111111111110101001010111111111010001101111111100111111111010010001010
<center>
</center>
</center>
</td>
</tr>
<tr>
<td colspan="14">
<center>
91 CF FE A5 7F D1 BF CF FA 45
<center>
</center>
</center>
</td>
</tr>
</tbody>
</table>
<p>
        最终我们使用了10个字节的空间保存了原本长度为64的数组，至此JPEG的主要压缩算法结束，这些数据就是保存在jpg文件中的最终数据。
</p>
<ol start="7" style="list-style-type: decimal">
<li>JFIF文件格式 <font style="color:red">JFIF 是 JPEG File Interchange Format 的缩写，也即 JPEG 文件交换格式</font>。JFIF 是一个图片文件格式标准，它是一种使用 JPEG 图像压缩技术存储摄影图像的方法。JFIF 代表了一种&quot;通用语言&quot;文件格式，它是专门为方便用户在不同的计算机和应用程序间传输 JPEG 图像而设计的语言。</li>
</ol>
<p>标签按照entropy-coded的数据序列插入到数据种，JFIF格式不是标准的文件格式，JFIF不允许在一个文件中存在多个图像，JFIF支持渐进的JPEG编码图像。JFIF 文件格式定义了一些内容是 JPEG 压缩标准未定义的，如 resolution/aspect ratio，color space 等。可选模式(Lossless JPEG,Progressive encoding,Hierarchical encoding). JPEG DCT允许多种参数，例如：Choice of quantizer tables／Choice of Huffman codes／Arithmetic coding／Different encoding of color and luminance</p>
<h2 id="motion-jpeg">Motion JPEG</h2>
<ul>
<li>MJPEG CODEC</li>
<li>Practical advantages of MJPEG</li>
<li>Disadvantage: <font style="color:red">poor compression performance</font></li>
</ul>
<h2 id="jpeg-2000">JPEG-2000</h2>
<p>Block-based DCT有很多缺点，<font style="color:red">最主要的是高度压缩的‘blockiness’</font>，BDCT是 以块为单元进行单独量化和编码 ，没有考虑像素在相邻块中的相关性，所以在<font style="color:red">低比特率编码时由于粗糙量化使得相邻块 的 DCT系数取样落在不同的量化区间时就会在块边界上产生方块效应</font> ，且比特率越低时方块效应越严重.</p>
<p>JPEG-2000有好的压缩效果，特别是高压缩率。还支持roi编码，此外应用了很多容错机制，这是一个开放的结构。JPEG-2000的计算如下：首先进行转换，通常是利用小波转换。然后是量化，小波变换后的系数会被根据重要性量化。交叉编码提供了更好的亚索（相对变长编码）。</p>
<center>
<b>计算复杂度比较</b>
</center>
<ul>
<li>1D DCT - N个输入输出样本 ~ <span class="math inline">\(N^2\)</span> = 64 operations (additions + multiplications)</li>
<li>2D DCT - 直接计算. <span class="math inline">\(M = N^2\)</span> input values, M output values -&gt; <span class="math inline">\(M^2 = N^4\)</span></li>
<li>2D DCT - 采用可分离计算, <span class="math inline">\(Y = TXT^T =ZT^T\)</span> , where <span class="math inline">\(Z = TX\)</span>, all matrices are <span class="math inline">\(N\times N -&gt; 2N^3\)</span> operations</li>
<li>For N = 8. 2D DCT direct — 4096 operations, 64 operations per pixel; 2D DCT separable — 1024 operations, 16 ops/pixel.Big savings due to separable transform. Inverse DFT — same story</li>
</ul>
</body>
</html>
