<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h2 id="sift">SIFT</h2>
<p>首先，我们为什么要关系匹配特征。很显然，这在很多地方用得上，例如：<font style="color:red">物体检测，匹配</font>。在日常中，有很多形式的不变性，例如：Illumination（亮度），Scale（尺度），Rotation（旋转），Affine（仿射变换），Full Perspective（全方位视角）。那么如何获得illumination invariance（光照不变性），<font style="color:red">最简单的就是归一化处理，这有很多种度量方法，例如随机树、Haar和sift</font>。</p>
<h3 id="关键点检测">关键点检测</h3>
<p>在SIFT算法中，无论是目标图像还是模板图像，都是用<font style="color:red">关键点来进行描述</font>。因此，对目标的识别过程便是提取关键点并进行匹配的过程。 <img src="http://s15.sinaimg.cn/mw690/002hqofdzy6GwYenEd06e&amp;690" /> 上图展示了用SIFT算法进行目标识别的过程：<font style="color:red">首先提取中图像中的关键点，生成能够描述并代表该图像的关键点集。接下来通过比较关键点集，进而进行识别</font>。可见，要实现较好的匹配，首先要能生成准确代表图像的关键点。</p>
<h3 id="定义关键点">定义关键点</h3>
<p>在SIFT中，关键点定义为十分突出的、不会因光照条件改变而消失的点。<font style="color:red">角点、边缘点、暗区域的亮点以及亮区域的暗点都是符合此要求的点</font>。若两幅图像中存在相同的物体，虽然不同条件下所成的像往往会差别很大，但因为该物体关键点不会随各种外部条件影响而变化，所以通过比较图中的关键点便能够对物体做出鉴别。为了能检测图像的边缘、角点，进而得到关键点的描述，需要引入<font style="color:red">尺度空间理论</font>。</p>
<p>尺度是用来精确地描述一个物体的大小。对于同一个事物，<font style="color:red">从不同距离观察，其大小不同，尺度也因此不同，尺度空间便是用来表示这种差别</font>。在尺度空间中，<font style="color:red">各图像的模糊程度随着尺度变大而逐渐变大</font>，能够模拟人在距离目标由近到远时目标在视网膜上所成像的变化过程。</p>
<p>在SIFT算法中，通过对原始图像进行<font style="color:red">尺度变换</font>，获得该图像在多尺度下的尺度空间表示序列。这样，图片就被映射为多个尺度上的关键点，<font style="color:red">尽管两幅图片处于不同的尺度，但却可以提取出在尺度变换中没有改变的关键点</font>。从而能够不受尺度不同的影响，进行关键点匹配，识别出物体。</p>
<p><font style="color:red">高斯核是唯一可以产生多尺度空间而不引起其他附加变化的卷积核</font>。其定义如下： <span class="math display">\[
G(x_i,y_i,\sigma)=\frac{1}{2\pi \sigma^2}\exp\left(\frac{-((x-x_i)^2+(y-y_i)^2)}{2\sigma^2}\right)=\frac{1}{2\pi \sigma^2}\exp{-\frac{r^2}{2\sigma^2}}
\]</span> 其中，<span class="math inline">\(r=\sqrt{(x-x_i)^2+(y-y_i)^2}\)</span>为模糊半径。其图像如图所示 <img src="http://s3.sinaimg.cn/mw690/002hqofdzy6GwYxf1Ga52&amp;690" /></p>
<p>通过对图像进行高斯滤波，即将图像与高斯核进行卷积运算：<span class="math inline">\(L(x,y,\sigma)=G(x,y,\sigma)* I(x,y)\)</span>. 可以得到<font style="color:red">低噪声、低层次细节的新图像</font>，在视觉看上去更加模糊，称为高斯模糊图像，用此可以<font style="color:red">模拟图像的尺度变化</font>。用方差为sigma的高斯核进行运算得到新图像称为尺度空间为 的高斯模糊图像。 <img src="https://encrypted-tbn1.gstatic.com/images?q=tbn:ANd9GcQm4RGPi9rSDJc9a5IZkvHUfSIOzd2f5iUryRH_kCa4t7A0A3XlSg" /> 由二维高斯函数的特性可知，<font style="color:red">对一幅图像进行连续多次高斯模糊的效果与一次更大半径的高斯模糊可以产生同样的效果，大的高斯模糊的半径是所用多个高斯模糊半径平方和的平方根</font>。<b>例如，使用半径分别为 6 和 8 的两次高斯模糊变换得到的效果等同于一次半径为 10 的高斯模糊效果。</b></p>
<h3 id="构建高斯金字塔">构建高斯金字塔</h3>
<p><strong>如何获得尺度不变性？</strong></p>
<pre><code>- 将宽和高除以2
- 然后对每个像素做一个高斯模糊（也就是取相邻4个像素的点作为该点的值）。
- 重复这个过程，直到图像很小
- 在每一个图像上进行滤波，并且期望滤波器是鲁棒的。</code></pre>
<p>用<font style="color:red">不同sigma的高斯核对图像进行处理，得到不同尺度空间的图像</font>。可以用高斯金字塔对所有的图像尺度空间进行描述。其构建过程包括对图像做<font style="color:red">高斯平滑、降采样两部分</font>。为了让尺度体现其连续性，<font style="color:red">在简单下采样的基础上加上了高斯滤波</font>。由此，一幅图像可以产生几组(Octave)图像，一组图像包括几层(Interval)图像，共同构成了高斯金字塔。 <img src="http://s16.sinaimg.cn/mw690/002hqofdzy6GwYMFixx9f&amp;690" /></p>
<p><b>在高斯金字塔中。<font style="color:red">相邻两层图像间的尺度为 k 倍的关系</font>，同时<font style="color:red">相邻两组的同一层图像尺度为2倍的关系</font>。因此组内与组间尺度关系可以归纳为：</b> <span class="math display">\[
2^{i-1}(\sigma,k\sigma,k^2\sigma,\cdots,k^{n-1}\sigma)
\]</span> 其中<span class="math inline">\(k=2^{1/s}\)</span>, <span class="math inline">\(i\)</span>为金字塔组数，<span class="math inline">\(n\)</span>为每一组层数。<font style="color:red">因为图像在获取的时候，相机镜头已经对图像进行了一次初始的模糊，根据高斯模糊性质，初始<span class="math inline">\(\sigma\)</span>可以由下式获得</font>： <span class="math display">\[
\sigma=\sqrt{\sigma_{init}^2-\sigma_{pre}^2}
\]</span> 式中 <font style="color:red">第一项为第0层的尺度，第二项 为被相机模糊后的尺度</font>。<b>而高斯金字塔中组数可以由</b>： <span class="math display">\[
O=\log_2(\min(M,N))-3
\]</span> 进行求得。由此便可以根据图像的初始特征构造出高斯金字塔。</p>
<h3 id="构建dog差分算子">构建DoG差分算子</h3>
<p>通过高斯滤波构建尺度空间之后，<font style="color:red">为了消除尺度的差异</font>，考虑到尺度规范化的LoG算子(Laplacion of Gaussian算子)具有真正的尺度不变性[3]，需要<font style="color:red">在不同尺度的图像上进行Laplace运算(求二阶导数)，得到极值点，进而得出关键点</font>。为了简化运算，在此借助高斯算子 与 LoG 算子的关系进行转化。</p>
<p>尺度规范的LoG算子为：<span class="math inline">\(LoG(x,y,\sigma)=\sigma^2\nabla^2 G\)</span> 其中<span class="math inline">\(\nabla^2G\)</span>可以进一步由尺度规范化的高斯梯度函数算子<span class="math inline">\(GoG\)</span>算子进行计算： <span class="math display">\[
\nabla^2 G=\frac{\partial^2 G}{\partial x^2}+\frac{\partial^2 G}{\partial y^2}
\]</span> 对高斯梯度算子进行展开，将<span class="math inline">\(\sigma\)</span>系数的不同通过高斯函数的特性等效为<span class="math inline">\(\sigma\)</span>自身的变化，可以进一步近似计算出： <span class="math display">\[
LoG(x,y,\sigma)=\sigma^2\nabla^2G\simeq \frac{G(x,y,xk\sigma)-G(x,y,\sigma)}{\sigma^2(k-1)}
\]</span> 可以看出, LoG算子和高斯函数的差有直接关系，因此DoG定义为：<span class="math inline">\(LoG(x,y,\sigma)=[G(x,y,k\sigma)-G(x,y,\sigma)].I(x,y)\)</span></p>
<p>上式的含义是<font style="color:red">通过求相邻尺度高斯平滑后图像的差值，便可以得出 LoG 算子的值。由此可以省去复杂的求导运算，直接通过求差值来得出关键点。</font></p>
<h3 id="求局部极值点">求局部极值点</h3>
<p>为了寻找尺度空间的极值点，<font style="color:red">每一个采样点要和它所有的相邻点比较，看其是否比它的图像域和尺度域的相邻点大或者小</font>。</p>
<p>如图所示，中间的检测点和它同尺度的8个相邻点和上下相邻尺度对应的9×2个点共26个点比较，以确保在尺度空间和二维图像空间都检测到极值点。</p>
<p>一个点如果在DOG尺度空间本层以及上下两层的26个领域中是最大或最小值时，就认为该点是图像在该尺度下的一个特征点,如图所示。 <img src="http://my.csdn.net/uploads/201207/09/1341795693_8232.jpg" /> 同一组中的相邻尺度（由于k的取值关系，肯定是上下层）之间进行寻找 <img src="http://my.csdn.net/uploads/201207/09/1341799138_5040.jpg" /></p>
<p>在极值比较的过程中，<font style="color:red">每一组图像的首末两层是无法进行极值比较的，为了满足尺度变化的连续性，我们在每一组图像的顶层继续用高斯模糊生成了 3 幅图像</font>，高斯金字塔有每组S+3层图像。DOG金字塔每组有S+2层图像.</br> 这里有的童鞋不理解什么叫“<font style="color:red">为了满足尺度变化的连续性</font>”，现在做仔细阐述：</p>
<p>假设s=3，也就是每个塔里有3层，则<span class="math inline">\(k=2^{1/s}=2^{1/3}\)</span>，那么按照上图可得Gauss Space和DoG space 分别有3个（<span class="math inline">\(s\)</span>个）和2个（<span class="math inline">\(s-1\)</span>个）分量，在DoG space中，1st-octave两项分别是<span class="math inline">\(\sigma\)</span>,<span class="math inline">\(k\sigma\)</span>; 2nd-octave两项分别是<span class="math inline">\(2\sigma\)</span>,<span class="math inline">\(2k\sigma\)</span>;由于无法比较极值，我们必须在高斯空间继续添加高斯模糊项，使得形成<span class="math inline">\(\sigma\)</span>,<span class="math inline">\(k\sigma\)</span>,<span class="math inline">\(k2\sigma\)</span>,<span class="math inline">\(k3\sigma\)</span>,<span class="math inline">\(k4\sigma\)</span>这样就可以选择DoG space中的中间三项<span class="math inline">\(k\sigma\)</span>,<span class="math inline">\(k2\sigma\)</span>,<span class="math inline">\(k3\sigma\)</span>（只有左右都有才能有极值），那么下一octave中（由上一层降采样获得）所得三项即为<span class="math inline">\(2k\sigma\)</span>,<span class="math inline">\(2k^2\sigma\)</span>,<span class="math inline">\(2k^3\sigma\)</span>，其首项<span class="math inline">\(2k\sigma=2^{4/3}\)</span>。刚好与上一octave末项<span class="math inline">\(k^3\sigma=2^{3/3}\)</span>尺度变化连续起来，所以每次要在Gaussian space添加3项，每组（塔）共S+3层图像，相应的DoG金字塔有S+2层图像。</br> 使用Laplacian of Gaussian能够很好地找到找到图像中的兴趣点，但是需要大量的计算量，<font style="color:red">所以使用Difference of Gaussian图像的极大极小值近似寻找特征点.DOG算子计算简单，是尺度归一化的LoG算子的近似</font>.</p>
<h3 id="修正关键点">修正关键点</h3>
<p>因为DoG算子会产生<font style="color:red">较强的边缘响应，为了增强匹配稳定性、提高抗噪声能力，需要对尺度空间DoG函数进行曲线拟合</font>，以精确确定关键点的位置和尺度，同时<font style="color:red">除去低对比度的关键点和不稳定的边缘响应</font>。</p>
<h4 id="曲线拟合获得精确位置">曲线拟合，获得精确位置</h4>
<p>利用DoG函数在尺度空间的Taylor展开式，采用<font style="color:red">三维二次函数进行拟合</font>： <span class="math display">\[
D(X)=D+\frac{\partial D^T}{\partial X}X+\frac{1}{2}X^T\frac{\partial^2D}{\partial X^2}X
\]</span> 其中，<span class="math inline">\(X=(x,y,\sigma)^T\)</span>。对上式求导,并令其为0,得到精确的位置, 得<span class="math inline">\(0=\frac{\partial D}{\partial X}+\frac{\partial^2D}{\partial X^2}\hat{X}\)</span>, 那么<span class="math inline">\(\hat{X}\)</span>是关键点的位置信息<span class="math inline">\(\hat{X}=-\frac{\partial^2D^{-1}}{\partial X^2}\frac{\partial D}{\partial X}\)</span> 得到修正的精确位置 。按照此解分别对图像的行、列和尺度三个方向的量进行修正。</p>
<h4 id="去除低对比度点">去除低对比度点</h4>
<p>将修正后的位置 带入原方程中，取前两项，得：<span class="math inline">\(D(\hat{X})=D+\frac{1}{2}\frac{\partial D^T}{\partial X}\hat{X}\)</span> 如果<span class="math inline">\(|D(X)&gt;0.03|\)</span>, ，则认为该特征点有足够的对比度，应该予以保留，否则应该舍弃.</p>
<h4 id="去除边缘响应">去除边缘响应</h4>
<p>一个定义不好的高斯差分算子的极值在横跨边缘的地方有较大的主曲率，而在垂直边缘的方向有较小的主曲率。主曲率通过一个2×2 的Hessian矩阵H求出:<img src="http://my.csdn.net/uploads/201206/07/1339034274_1762.jpg" />,导数由采样点相邻差估计得到。</br></p>
<p>为主曲率<span class="math inline">\(D\)</span>和<span class="math inline">\(H\)</span>的特征值成正比，为了简化计算，不直接计算这些特征值，而是计算之间的比值。令 <span class="math inline">\(\alpha\)</span> 为最大特征值， <span class="math inline">\(\beta\)</span> 为最小特征值，则</p>
<p><span class="math display">\[
\frac{Tr(H)^2}{Det(H)}=\frac{(\alpha+\beta)^2}{\alpha\beta}
\]</span> 式中，<span class="math inline">\(\begin{cases}Tr(H)=D_{xx}+D_{yy}=\alpha+\beta\\Det(H)=D_{xx}D_{yy}-(D_{xy})^2=\alpha\beta\end{cases}\)</span>。　</p>
<p>令<span class="math inline">\(\alpha=r \beta\)</span>，则<span class="math inline">\(\frac{Tr(H)^2}{Det(H)}=\frac{(\alpha+\beta)^2}{\alpha\beta}=\frac{(r\beta+\beta)^2}{r\beta^2}=\frac{(r+1)^2}{r}\)</span></br></p>
<p><span class="math inline">\((r+1)2/r\)</span>的值在两个特征值相等的时候最小，随着r的增大而增大，因此，为了检测主曲率是否在某域值r下，只需检测<span class="math inline">\(\frac{Tr(H)^2}{Det(H)}&lt;\frac{(r+1)^2}{r}\)</span>,if <span class="math inline">\((\alpha+\beta)/{\alpha\beta}&gt; (r+1)^2/r\)</span>, throw it out. 在Lowe的文章中，取r＝10。</p>
<h3 id="确定关键点的方向">确定关键点的方向</h3>
<p>为了让<b><font style="color:red">关键点不会随图像的旋转变化而发生变化，还需要为每个关键点指明方向参数，使算子具有旋转不变性</font></b>。采用梯度来对每个像素确定方向，可以通过以下公式进行计算。</p>
<p>幅度：<span class="math inline">\(m(x,y)=\sqrt{(L(x+1,y)0L(x-1,y))^2+(L(x,y+1)-L(x,y-1))^2}\)</span> 方向：<span class="math inline">\(\theta(x,y)=a\tan 2((L(x,y+1)-L(x,y-1))/(L(x+1,y)-L(x-1,y)))\)</span></p>
<p><font style="color:red">通过统计以关键点为原点，一定区域内(建议统计半径为4.5 )所有像素的方向与幅值，来综合确定关键点的方向</font>。采用直方图法，以10°为统计区间，将该区域内像素按照方向分类，把每个方向像素幅值和作为统计量。最终选择直方图中幅值最大的方向作为关键点的主方向，其示意图如图。</p>
<p><img src="http://s14.sinaimg.cn/mw690/002hqofdzy6GwZV1dP77d&amp;690" /> 为了提高匹配的鲁棒性，若存在其他方向，其幅值相当于主方向幅值的80% 以上，则选取该方向作为辅方向。</p>
<p>梯度直方图的范围是0～360度，其中每10度一个柱，总共36个柱。随着距中心点越远的领域其对直方图的贡献也响应减小.Lowe论文中还提到要使用高斯函数对直方图进行平滑，减少突变的影响。 在实际计算时，我们在以关键点为中心的邻域窗口内采样，并用直方图统计邻域像素的梯度方向。梯度直方图的范围是0～360度，其中每45度一个柱，总共8个柱, 或者每10度一个柱，总共36个柱。Lowe论文中还提到要使用高斯函数对直方图进行平滑，减少突变的影响。直方图的峰值则代表了该关键点处邻域梯度的主方向，即作为该关键点的方向。 <img src="http://my.csdn.net/uploads/201206/07/1339035957_9140.jpg" /> 直方图中的峰值就是主方向，其他的达到最大值80%的方向可作为辅助方向 <img src="http://my.csdn.net/uploads/201206/06/1338991000_6352.jpg" /> 由梯度方向直方图确定主梯度方向, 该步中将建立所有scale中特征点的描述子（128维） <img src="http://my.csdn.net/uploads/201207/09/1341803497_9598.png" /> 关键点描述子的生成步骤<img src="http://my.csdn.net/uploads/201207/09/1341803542_3504.png" /> 通过对关键点周围图像区域分块，计算块内梯度直方图，生成具有独特性的向量，这个向量是该区域图像信息的一种抽象，具有唯一性。</p>
<h3 id="对关键点进行描述">对关键点进行描述</h3>
<p>通过以上各步，已经获得了每个关键点的<font style="color:red">位置、尺度及方向三个信息</font>，分别对应<font style="color:red">平移、缩放与旋转的不变性</font>。但是各个关键点仅仅是独立的存在，没有考虑到<font style="color:red">周围像素点与关键点之间的关系</font>。对关键点进行描述便是通过选取关键点及其邻域的像素，共同表达这个整体的特征。</p>
<p>以关键点为中心，首先根据关键点所在组的尺度sigma，用下式计算所取图像的采样半径： <span class="math display">\[
\text{radius}=\frac{3\delta\sqrt{2}(d+1)+1}{2}
\]</span> 接下来，旋转坐标轴，以关键点的主方向作为0°方向，得到旋转后转化的新坐标为：<img src="http://s10.sinaimg.cn/mw690/002hqofdzy6Gx0dn0cp59&amp;690" /></p>
<p>然后以关键点为中心，在所计算的采样区域(半径为 )内，计算每个像素的梯度的幅值与方向，其中方向按照八个方向(0°,45°,90°,…,315°)进行归类。然后将所有像素的梯度分别在4个窗口中进行直方图统计，累加形成一个种子点。</p>
<div class="figure">
<img src="http://s7.sinaimg.cn/mw690/002hqofdzy6Gx0fZqf456&amp;690" />

</div>
<p>因为每个 的窗口包含了<font style="color:red">32维度的信息，而整个的邻域共有4个这样的窗口</font>，因此最终每个SIFT的关键点共有128维的信息。<font style="color:red">为了去除光照的影响，还需要对这128维的信息进行归一化操作，以便适应更复杂的环境</font>： <span class="math display">\[
L=\frac{W}{\sqrt{\sum_{i=1}^128 w_i^2}}
\]</span></p>
<h2 id="sift变换的改进">SIFT变换的改进</h2>
<p>SIFT算法提出之后，在目标匹配方面有着非常好的效果，但是仍然存在算法复杂，较难实现实时处理、对于边缘模糊目标无法准确识别等问题。为了解决这些问题，许多改进算法被提出，对其部分性能进行了优化。 ### PCA-SIFT算法 该算法针对SIFT算法中128维算子数据量较大的问题，采用主成分分析法(Principal Component Analysis, PCA)对其进行降维，简化描述算子的尺度，进而简化计算量。 ### C-SIFT 因为最初Lowe 教授提出的SIFT算法是针对灰度图像的。在2006年Farag提出了基于彩色图像的SIFT，使得对于彩色图像同样能够进行特征提取与识别。 ### SURF 由Bay在2006年提出，采用box filter与原始图像进行卷积，易于进行并行计算，并将SIFT中关键点的邻域形状由矩形变为圆形，计算小波响应。其计算量与SIFT相比大大减小，运算速度有很大的提高。 ### A-SIFT 由Morel在2009年提出，可以防止仿射情况的产生。该算法由两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换接上一个平移组成，提取的特征点比SIFT算法要多。</p>
</body>
</html>
