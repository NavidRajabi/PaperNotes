<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h2 id="模拟退火白话">模拟退火白话</h2>
<ol style="list-style-type: decimal">
<li>爬山算法 ( Hill Climbing )</li>
</ol>
<p>爬山算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。</p>
<p>爬山算法实现很简单，其主要缺点是会陷入局部最优解，而不一定能搜索到全局最优解。如图1所示：假设C点为当前解，爬山算法搜索到A点这个局部最优解就会停止搜索，因为在A点无论向那个方向小幅度移动都不能得到更优的解。</p>
<p align="center">
<img src="http://pic002.cnblogs.com/images/2010/63234/2010122016525713.png" width="250" >
</p>
<p align="center">
图1.
</p>
<p align="center">
<img src="http://www.handmade-insights.com/blog/2013/genetic-algorithms/state_space_landscape.png" width="250" >
</p>
<ol start="2" style="list-style-type: decimal">
<li>模拟退火(SA,Simulated Annealing)</li>
</ol>
<p>爬山法是完完全全的贪心法，每次都鼠目寸光的选择一个当前最优解，因此只能搜索到局部的最优值。模拟退火其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以<strong><em>一定的概率</em></strong>来接受一个比当前解要差的解，因此<strong><em>有可能</em></strong>会跳出这个局部的最优解，达到全局的最优解。以图1为例，模拟退火算法在搜索到局部最优解A后，会以一定的概率接受到E的移动。也许经过几次这样的不是局部最优的移动后会到达D点，于是就跳出了局部最大值A。</p>
<p>模拟退火算法描述：</p>
<ul>
<li>若<span class="math inline">\(J( Y(i+1) )\ge J( Y(i) )\)</span> (即移动后得到更优解)，则总是接受该移动</li>
<li>若<span class="math inline">\(J( Y(i+1) )&lt; J( Y(i) )\)</span> (即移动后的解比当前解要差)，则<strong><em>以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）</em></strong></li>
</ul>
<p>这里的“<strong><em>一定的概率</em></strong>”的计算参考了金属冶炼的退火过程，这也是模拟退火算法名称的由来。</p>
<p>根据热力学的原理，在温度为<span class="math inline">\(T\)</span>时，出现能量差为<span class="math inline">\(dE\)</span>的降温的概率为<span class="math inline">\(P(dE)\)</span>，表示为：<span class="math inline">\(P(dE)=exp(dE/(kT))\)</span>, 其中<span class="math inline">\(k\)</span>是一个常数，<span class="math inline">\(exp\)</span>表示自然指数，且<span class="math inline">\(dE&lt;0\)</span>。这条公式说白了就是：温度越高，出现一次能量差为<span class="math inline">\(dE\)</span>的降温的概率就越大；温度越低，则出现降温的概率就越小。又由于<span class="math inline">\(dE\)</span>总是小于0（否则就不叫退火了），因此 <span class="math inline">\(dE/kT &lt; 0\)</span> ，所以<span class="math inline">\(P(dE)\)</span>的函数取值范围是(0,1).</p>
<p>随着温度T的降低，<span class="math inline">\(P(dE)\)</span>会逐渐降低。</p>
<p>我们将一次向较差解的移动看做一次温度跳变过程，我们以概率<span class="math inline">\(P(dE)\)</span>来接受这样的移动。</p>
<p>关于爬山算法与模拟退火，有一个有趣的比喻：</p>
<p>爬山算法：<em>兔子朝着比现在高的地方跳去。它找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是爬山算法，它不能保证局部最优值就是全局最优值。</em></p>
<p>模拟退火：<em>兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，它渐渐清醒了并朝最高方向跳去。这就是模拟退火。</em></p>
<ol start="3" style="list-style-type: decimal">
<li>模拟退火算法伪代码</li>
</ol>
<p>下面给出模拟退火的伪代码表示。</p>
<pre><code>/*
* J(y)：在状态y时的评价函数值
* Y(i)：表示当前状态
* Y(i+1)：表示新的状态
* r： 用于控制降温的快慢
* T： 系统的温度，系统初始应该要处于一个高温的状态
* T_min ：温度的下限，若温度T达到T_min，则停止搜索
*/
while( T &gt; T_min )
{
　　dE = J( Y(i+1) ) - J( Y(i) ) ;

　　if ( dE &gt;=0 ) //表达移动后得到更优解，则总是接受移动
        Y(i+1) = Y(i) ; //接受从Y(i)到Y(i+1)的移动
　　else
　　{
        // 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也
        if ( exp( dE/T ) &gt; random( 0 , 1 ) )
            Y(i+1) = Y(i) ; //接受从Y(i)到Y(i+1)的移动
　　}
　　T = r * T ; //降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快
　　/* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值*/
　　i ++ ;
}</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>使用模拟退火算法解决旅行商问题</li>
</ol>
<p><strong><em>旅行商问题 ( TSP , Traveling Salesman Problem ) ：有N个城市，要求从其中某个问题出发，唯一遍历所有城市，再回到出发的城市，求最短的路线。</em></strong></p>
<p>旅行商问题属于所谓的NP完全问题，精确的解决TSP只能通过<strong><em>穷举</em></strong>所有的路径组合，其时间复杂度是<strong><em>O(N!)</em></strong> 。</p>
<p>使用模拟退火算法可以比较快的求出TSP的一条近似最优路径。模拟退火解决TSP的思路：</p>
<ol style="list-style-type: decimal">
<li>使产生一条<strong><em>新</em></strong>的遍历路径<span class="math inline">\(P(i+1)\)</span>，计算路径<span class="math inline">\(P(i+1)\)</span>的长度<span class="math inline">\(L( P(i+1) )\)</span>;</li>
<li>若<span class="math inline">\(L(P(i+1)) &lt; L(P(i))\)</span>，则接受<span class="math inline">\(P(i+1)\)</span>为新的路径，否则以模拟退火的那个概率接受<span class="math inline">\(P(i+1)\)</span> ，然后降温;</li>
<li>重复步骤1，2直到满足退出条件.</li>
</ol>
<p>产生新的遍历路径的方法有很多，下面列举其中3种： (1) 随机选择2个节点，交换路径中的这2个节点的顺序。 (2) 随机选择2个节点，将路径中这2个节点间的节点顺序逆转。 (3) 随机选择3个节点m，n，k，然后将节点m与n间的节点移位到节点k后面。</p>
<ol start="5" style="list-style-type: decimal">
<li>算法评价</li>
</ol>
<p>模拟退火算法是一种<span style="color:red"><strong><em>随机算法，并不一定能找到全局的最优解，可以比较快的找到问题的近似最优解</em></strong></span>。 如果参数设置得当，模拟退火算法搜索效率<span style="color:red"><strong>比穷举法要高</strong>*</span>。</p>
<p><strong>Reference</strong>: <a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html">大白话解析模拟退火算法</a></p>
</body>
</html>
