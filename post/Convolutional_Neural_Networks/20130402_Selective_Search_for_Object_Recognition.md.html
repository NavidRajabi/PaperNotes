<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h2 id="selective-search-for-object-recognition"><a href="http://koen.me/research/pub/uijlings-ijcv2013-draft.pdf">Selective Search for Object Recognition</a></h2>
<p>项目网址：http://koen.me/research/selectivesearch/</p>
<h2 id="what-is-an-object"><strong>What is an object</strong>?</h2>
<p align="center">
<img src="http://i.imgur.com/cBm4V5f.png" width="600" >
</p>
<p>如何判别哪些<strong>region属于同一个物体</strong>？这个问题找不到一个统计的答案：</p>
<ol style="list-style-type: decimal">
<li>对于图b，我们可以根据颜色来分开两只猫，但是不能根据纹理来分开。</li>
<li>对于图c，我们可以根据纹理来找到变色龙，但是不能根据颜色来找到。</li>
<li>对于图d，我们将车轮归类成车的一部分，既不是因为颜色相近，也不是因为纹理相近，而是因为车轮附加在车的上面（个人理解是因为车“包裹”这车轮）</li>
<li>所以，我们需要用多种策略结合，才有可能找到图片中的所有物体。</li>
<li>另外，图a说明了物体之间可能具有的层级关系，或者说一种嵌套的关系——勺子在锅里面，锅在桌子上。</li>
</ol>
<h2 id="multiscale">Multiscale</h2>
<p align="center">
<img src="http://i.imgur.com/rVuYX8g.png" width="600" >
</p>
<p>由于物体之间存在<strong>层级关系</strong>，所以Selective Search用到了<strong>Multiscale的思想</strong>。从上图看出，Select Search在不同尺度下能够找到不同的物体。</p>
<p>注意，这里说的不同尺度，<strong>不是指通过对原图片进行缩放，或者改变窗口大小的意思</strong>，而是，通过<strong>分割的方法将图片分成很多个region</strong>，并且用<strong>合并（grouping）的方法将region聚合成大的region</strong>，重复该过程<strong>直到整张图片变成一个最大的region</strong>。这个过程就能够生成<strong>multiscale的region了</strong>，而且，也符合了上面“<strong><em>物体之间可能具有层级关系</em></strong>”的假设。</p>
<h2 id="selective-search方法简介"><strong><em>Selective Search方法简介</em></strong></h2>
<p>使用<a href="http://cs.brown.edu/~pff/segment/">Efficient GraphBased Image Segmentation</a>中的方法来得到region</p>
<ol style="list-style-type: decimal">
<li>得到所有region之间<strong><em>两两的相似度</em></strong></li>
<li><strong><em>合并最像的两个region</em></strong></li>
<li>重新计算新合并region<strong><em>与其他region的相似度</em></strong></li>
<li><strong><em>重复</em></strong>上述过程直到整张图片都聚合成<strong><em>一个大的region</em></strong></li>
<li>使用一种<strong><em>随机的计分方式给每个region打分，按照分数进行ranking，取出top k的子集</em></strong>，就是selective search的结果</li>
</ol>
<p>细节看下面两节。</p>
<h2 id="策略多样化diversification-strategies"><strong><em>策略多样化（Diversification Strategies）</em></strong></h2>
<p>有两种多样化方法，一个是<strong><em>针对样本的颜色空间</em></strong>，另一个针对<strong><em>合并时候计算相似性的策略</em></strong>。 采用了<strong><em>8种颜色空间</em></strong>，包括<strong><em>RGB，灰度图，Lab</em></strong>，等等 采用了<strong><em>4种相似性</em></strong>：颜色相似性（对应Figure1a的情况），纹理相似性（对应Figure1b的情况），小物体先合并原则，物体之间的相容性（对应Figure1d的情况）</p>
<h2 id="如何对region打分"><strong><em>如何对region打分</em></strong>？</h2>
<p>这里不是太确定，但是按照作者描述以及个人理解，觉得确实就是<strong><em>随机地打分</em></strong>。</p>
<p>对于<strong><em>某种合并策略<span class="math inline">\(j\)</span></em></strong>，定义<span class="math inline">\(r_i^j\)</span>为位置在<span class="math inline">\(i\)</span>的region，其中<span class="math inline">\(i\)</span>代表它在合并时候的所位于的层数（i=1表示在整个图片为一个region的那一层，往下则递增），那么定义<strong><em>其分数为<span class="math inline">\(v)i^j=RND\times i\)</span>，其中RND为[0, 1]之间的一个随机值</em></strong>。</p>
<h2 id="使用selective-search进行object-recogntion"><strong><em>使用Selective Search进行Object Recogntion</em></strong></h2>
<p align="center">
<img src="http://i.imgur.com/hu5G1TI.png" width="600" >
</p>
<p>大致流程如上图。用的是传统的“特征+SVM”方法：</p>
<ol style="list-style-type: decimal">
<li>特征用了HoG和BoW</li>
<li>SVM用的是SVM with a histogram intersection kernel</li>
<li>训练时候：正样本：groundtruth，负样本，seletive search出来的region中overlap在20%-50%的。</li>
<li>迭代训练：一次训练结束后，选择分类时的false positive放入了负样本中，再次训练</li>
</ol>
<h2 id="评估evalutation">评估（evalutation）</h2>
<p>用数据和表格说明了文中的方法有效。 这部分写了很长，具体不表。</p>
</body>
</html>
