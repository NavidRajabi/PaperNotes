<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<h1 id="why-we-need-schedule-sampling">Why we need <strong><em>Schedule sampling</em></strong></h1>
<p>I've recently read a paper on a technique called <em>Scheduled Sampling</em> for RNNs by Samy Bengio and colleagues at Google.</p>
<blockquote>
<p>Samy Bengio, Oriol Vinyals, Navdeep Jaitly, Noam Shazeer (2015): Scheduled Sampling for Sequence Prediction with Recurrent Neural Networks</p>
</blockquote>
<p>Google's team developed scheduled sampling as an alternative training procedure to fit RNNs, and they used it in their competition-winning method for image captioning.</p>
<h1 id="strictly-proper-scoring-rules">Strictly proper scoring rules</h1>
<p>Scoring rules are essentially loss functions for probabilistic models/forecasts. A scoring rule <span class="math display">\[
S(x,Q)
\]</span></p>
<p>simply measures how bad a probabilistic forecast <span class="math inline">\(Q\)</span> for a variable is in the light of actual observation <span class="math inline">\(x\)</span>. In this notation, lower is better. A scoring rule is called strictly proper, if for any <span class="math inline">\(P\)</span>, the following holds: <span class="math display">\[
\underset{Q}{\operatorname{argmax}}  \mathbb{E}_{x\sim P}S(x,Q) = P
\]</span></p>
<p>In other words, if you repeatedly sample observations from some true underlying distribution <span class="math inline">\(P\)</span>, then the model <span class="math inline">\(Q\)</span> which minimises expected score is <span class="math inline">\(P\)</span>. This means that the scoring rule cannot be fooled and that minimising the expected score yields a consistent estimator for <span class="math inline">\(P\)</span>. Because I mention consistency, people may dismiss this as a learning theory argument, but it is not. If you are a Bayesian or a deep learning person with no interest in consistency, a scoring rule being strictly proper simply means that it is safe to use it as a loss function. Anything that's not strictly proper is weird and wrong, it will lead to learning the wrong thing.</p>
<p>This concept is central in unsupervised learning and generative modelling. Unsupervised learning is all about modelling the probability distribution of data, so it's essential that we have loss functions that can measure the discrepancy between our model <span class="math inline">\(Q\)</span>, and the true data distribution <span class="math inline">\(P\)</span> in a consistent way.</p>
<h2 id="log-likelihood">log-likelihood</h2>
<p>One of the most frequently used strictly proper scoring rule is the logarithmic score: <span class="math display">\[
S(x,Q) = - \log Q(x)
\]</span> This quantity is also known as the <font style="color:red">negative log-likelihood</font>. Minimising the expected score in an i.i.d scenario yields <font style="color:red">maximum likelihood estimation</font>, which is known to be a consistent estimator and has nice properties.</p>
<p>Often, the likelihood is impossible to evaluate. Luckily, it is not the only strictly proper scoring rule. In the context of generative models people have used the pseudolikelihood, score matching and moment matching, all of which are examples of strictly proper scoring rules.</p>
<p>To recap, any learning method that corresponds to minimising a strictly proper scoring rule is fine, everything else can go horribly wrong, even if we feed it infinite data, it might just learn the wrong thing.</p>
<h2 id="scheduled-sampling">Scheduled Sampling</h2>
<p>After successfully establishing myself as a proper-scoring-rule-nazi, let's talk about scheduled sampling (SS).</p>
<p>SS is a new method to train recurrent neural networks(<font style="color:red">RNNs</font>) to model sequences. I will use character-by-character models of text as an example. Typically, when you train an RNN, you aim to <font style="color:red">minimise the log predictive likelihood in predicting the next character in each training sentence, given the prefix string of previous characters</font>. This can be thought of as a special case of <font style="color:red">maximum likelihood learning</font>, and is all fine, you can actually do this properly <font style="color:red">without approximations</font>.</p>
<p>After training, you use the RNN to <font style="color:red">generate sample sentences in a recursive fashion</font>: assuming you've already generated <span class="math inline">\(n\)</span> characters, you feed that prefix into the RNN, and ask it to predict the <span class="math inline">\(n+1\)</span> st character. The <span class="math inline">\(n+1\)</span> st character is then added to the prefix to predict the <span class="math inline">\(n+2\)</span> th character, and so on.</p>
<p>The authors say <u><b><font style="color:red">there is a disconnect between how the model is trained (it's always fed real data) and how it's used (it's always fed synthetic data generated by itself). This, they argue, leads to the RNN being unable to recover from its own mistakes early on in the sentence.</font></b></u></p>
<p>To address this, the authors propose an <font style="color:red">alternative training strategy</font>, where every once in a while, the network is given its <u><font style="color:red">own synthetic data instead of real data at training time</font></u>. More specifically, for each character in the training sentences, <b><u>we flip a coin to decide whether we feed the character from the real training sentence, or whether to feed the model's own prediction as to what that character would have been</u></b>. <font style="color:red">The authors claim this makes the model more robust to recovering from mistakes, which is probably true. (see the figure below)</font></p>
<center>
<img src="https://i.ytimg.com/vi/agA-rc71Uec/maxresdefault.jpg" width="400"></img>
</center>
<h2 id="case-study-sequence-of-two-variables">case study: sequence of two variables</h2>
<p>For sake of simplicity, let's consider using scheduled sampling to learn the joint distribution of a sequence of just two random variables. This is probably the simplest (shortest) time series I can think of. So SS in this case works as follows:</p>
<ol style="list-style-type: decimal">
<li>For each datapoint train the network to predict the real <span class="math inline">\(x_1\)</span>.</li>
<li>Then we <font style="color:red">flip a coin</font> to decide whether to keep <span class="math inline">\(x_1\)</span> from the datapoint, or to replace it with a sample from the model <span class="math inline">\(Q_{x_1}\)</span>.</li>
<li>Then we train <span class="math inline">\(Q_{x_2|x_1}\)</span> on the <span class="math inline">\((x_1,x_2)\)</span> pair obtained this way.</li>
</ol>
<p>The scoring rule for selective sampling looks something like this: <span class="math display">\[
S(Q_{x_1,x_2},(x_1,x_2)) = - (1 - \epsilon) [ \mathbb{E}_{z \sim Q_{x_1}} \log Q_{x_2 \vert x_1}(x_2 \vert z) + \log Q_{x_1}(x_1)] - \epsilon \log Q_{x_2 , x_1}(x_1,x_2),
\]</span> where <span class="math inline">\(\epsilon\)</span> is the probability with wich the true <span class="math inline">\(x_1\)</span> is used.</p>
<p><b><u><font style="color:red">The authors suggest starting training with <span class="math inline">\(\epsilon=1\)</span> and annealing it so that by the end of the training <span class="math inline">\(\epsilon=0\)</span></font></u></b>. So as far as the eventual optimum of SS is concerned, we only have to focus on what the first term of the scoring rule does. The second term is the good old log-likelihood so we know that part works.</p>
<p>After some math, one can show that scheduled sampling with a fixed <span class="math inline">\(\epsilon\)</span> minimises the following divergence between the true <span class="math inline">\(P\)</span> and the model <span class="math inline">\(Q\)</span>: <span class="math display">\[
D_{SS}[P\|Q] = KL[P_{x_1}\|Q_{x_1}] + (1-\epsilon) \mathbb{E}_{z\sim Q_{x_1}} KL[P_{x_2}\|Q_{x_2\vert x_1=z}] + \epsilon KL[P_{x_2\vert x_1}\|Q_{x_2\vert x_1}]
\]</span></p>
<p>Now, if <span class="math inline">\(\epsilon=1\)</span>, we recover the Kullback-Leibler divergence between the joint <span class="math inline">\(P_{x1,x2}\)</span> and <span class="math inline">\(Q_{x1,x2}\)</span>, which is what we expect as it corresponds to maximum likelihood estimation. However, as <span class="math inline">\(\epsilon\)</span> is annealed to <span class="math inline">\(0\)</span>, the objective function is somewhat strange, whereby the conditional distribution <span class="math inline">\(Q_{x_2\vert x_1}\)</span> is pushed to model the marginal distribution <span class="math inline">\(P_{x_2}\)</span>, instead of <span class="math inline">\(P_{x_2|x_1}\)</span> as one would expect. One can therefore see that the factorised <span class="math inline">\(Q^{\ast} = P_{x_1}P_{x_2}\)</span> minimises this objective function.</p>
<h1 id="what-this-means-for-text-modelling">what this means for text modelling</h1>
<p>Extrapolating from the two variable case to longer sequences, one can see that the <font style="color:red">scheduled sampling objective would fail if minimised properly until convergence</font>. Consider the case when the <span class="math inline">\(\epsilon\approx 0\)</span> stage is reached in the annealing schedule. Now consider what the RNN has to do to predict the <span class="math inline">\(n\)</span>-th character in a string during training. It is fed a random prefix string that was generated by itself but never seen any real data. <font style="color:red">Then the RNN has to give a probabilistic forecast of what the <span class="math inline">\(n\)</span> th character in the training sentence is, having seen none of the previous characters in the sentence.</font></p>
<p><b><u>The optimal model that minimises this objective would completely ignore all the characters in the sentence so far</u></b>, but keep a simple linear counter that indexes where it is within the sentence. Then it would emit a character from an index-specific marginal distribution of characters. This is the equivalent of the factorised trivial solution above.</p>
<p>Yes, such a model would be better at &quot;<font style="color:red">recovering from its own mistakes</font>&quot;, because at every character it would start independently from what it has generated so far. <font style="color:red">But this is at the cost of paying no attention whatsoever as to what the prefix of the sentence was</font>. <b><font style="color:red">I believe the reason why this trivial behaviour was not observed in the paper is that the authors did not run the optimisation until convergence, and did not implement the full gradient of the objective function, as they discuss in the paper.</b></font></p>
<h1 id="constructive-part-of-criticism">Constructive part of criticism</h1>
<h2 id="what-to-do-instead-of-ss">What to do instead of SS?</h2>
<p>So the <font style="color:red">observed problem was that RNNs trained via maximum likelihood are unable to recover from their own mistakes early on in a sentence, when they are used to generate</font>.</p>
<blockquote>
<p>The main reason for the observed problem is that the log-likelihood is a <a href="http://arxiv.org/pdf/1101.5011.pdf">local scoring rule</a></p>
</blockquote>
<p>The local property of scoring rules means that at training time we only ever evaluate the model <span class="math inline">\(Q\)</span> on actually observed datapoints. So if the RNN is faced with a prefix subsequence that was not in the dataset, God knows what it's going to complete that sentence with.</p>
<p>The proper (shall I say strictly proper) way to fix this issue is to <font style="color:red">use a non-local strictly proper scoring rule</font>. Luckily, local proper scoring rules are actually pretty rare, so we can use a number of alternatives that should certainly improve things. For example, maximum mean discrepancy as in <a href="http://arxiv.org/abs/1502.02761">Generative Moment Matching Networks</a> would be an excellent starting point. This is a version of <a href="http://arxiv.org/abs/1406.2661">adversarial training</a>, and although it may be a pain to implement and to get it working, this may be the right approach for training RNNs with good out-of-sample performance as well.</p>
<blockquote>
<p>bottom line: what is a good generative model?</p>
</blockquote>
<p>The main message here is that we have to be clear about <font style="color:red">how we evaluate probabilistic models</font>. Very often, generative models are evaluated on the visual or perceptual quality of the samples they generate, rather than on objective terms of how well they model the distribution we wanted them to model. We are often looking for realistic samples, but not too realistic so we can still argue the model generalises well. But I think this practice is wrong, and is not sufficient to understand what really is going on or to detect overfitting. The main point is: being able to generate nice samples is not the same as being a good generative model in the probabilistic sense.</p>
</body>
</html>
